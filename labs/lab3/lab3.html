<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lab 3: Keypad Scanner – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../labs.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#design-and-testing-methodology" id="toc-design-and-testing-methodology" class="nav-link" data-scroll-target="#design-and-testing-methodology">Design and Testing Methodology</a>
  <ul class="collapse">
  <li><a href="#clock-debouncing" id="toc-clock-debouncing" class="nav-link" data-scroll-target="#clock-debouncing">Clock Debouncing</a></li>
  <li><a href="#top-level-module" id="toc-top-level-module" class="nav-link" data-scroll-target="#top-level-module">Top Level module</a></li>
  <li><a href="#module-resuse" id="toc-module-resuse" class="nav-link" data-scroll-target="#module-resuse">Module Resuse</a></li>
  <li><a href="#eye-test" id="toc-eye-test" class="nav-link" data-scroll-target="#eye-test">Eye test</a></li>
  </ul></li>
  <li><a href="#technical-documentation" id="toc-technical-documentation" class="nav-link" data-scroll-target="#technical-documentation">Technical Documentation:</a>
  <ul class="collapse">
  <li><a href="#block-diagram" id="toc-block-diagram" class="nav-link" data-scroll-target="#block-diagram">Block Diagram</a></li>
  <li><a href="#schematic" id="toc-schematic" class="nav-link" data-scroll-target="#schematic">Schematic</a></li>
  <li><a href="#fsm-diagrams-and-tables" id="toc-fsm-diagrams-and-tables" class="nav-link" data-scroll-target="#fsm-diagrams-and-tables">FSM Diagrams and Tables</a></li>
  </ul></li>
  <li><a href="#results-and-discussion" id="toc-results-and-discussion" class="nav-link" data-scroll-target="#results-and-discussion">Results and Discussion</a>
  <ul class="collapse">
  <li><a href="#testbench-simulation" id="toc-testbench-simulation" class="nav-link" data-scroll-target="#testbench-simulation">Testbench Simulation</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#ai-prototype-summary" id="toc-ai-prototype-summary" class="nav-link" data-scroll-target="#ai-prototype-summary">AI Prototype Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 3: Keypad Scanner</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This lab aimed to build upon Labs 1 and 2 with clock multiplexing and seven segment displays, to build a keypad scanner that displays the last two digits pressed. This required dealing with clock bouncing, and asyncronous inputs.</p>
</section>
<section id="design-and-testing-methodology" class="level2">
<h2 class="anchored" data-anchor-id="design-and-testing-methodology">Design and Testing Methodology</h2>
<p>This lab included a lot of separate parts that had to be tested independetly to have a working design. Thus, I created many submodules that could be independetly tested with testbenches. I wrote modules to deal with asyncronous inputs, and the rest of my design fully assumes that these inputs work as expected.</p>
<section id="clock-debouncing" class="level3">
<h3 class="anchored" data-anchor-id="clock-debouncing">Clock Debouncing</h3>
<p>One inherant problem of using physical switches is the problem of clock bouncing or jitter. This is a short period when the switch is first pressed when the physical contact vibrate and might not read a stable value. This would result in a single press being read as multiple key strokes, and could also complicate function when one key is held down and another is pressed immediately after.</p>
<p>The strategy that I used to deal with this problem was to keep track of a button that is pressed, and wait for a specified number of cycles before going back into a scanning mode. During these cycles, if the key is detected again, it resets the counter. Therfore, while a button is in a clock jitter phase or help down for a long time, the count will keep resetting and the system will stay in the active state and not return to the scanning state.</p>
<p>This has the advantages of detecting a keypress essentially instantaenously. Other strategies, such as a low-pass filter can cause significant delays in seeing a digit be recognized. Additionally, it combines the debouncing with the handling of simultaneous inputs or an input while a key is being held. This group of interacting FSMs does a lot of the heavy lifting to ensure correct functionality of the system. It also is able to do a good job of detecting the same button pressed multiple times (different to clock jitter, this is an actual human clicking a button multiple times) as once the set number of cycles without a button push is reached it is now scanning for new buttons, and this includes the same button that was just released.</p>
<p>Similar to the low-pass filter, another strategy would be to wait for a certain number of consecutive cycles to “agree” that a switch has been pressed. Even if the delay is minimal, this still requires a delay from a switch being pressed to being officially detected and displayed on the seven segment display. My method has the detection on the first leading edge of a new clock press, and handles the bounce on the backend instead of the frontend.</p>
<p>Another option is to slow the clock down significantly. My method allowed me to use a 6 MHz clock with no issues, and this made sure that everything was very responsive and quick. By dividing this clock this would also reduce the response time. This method still requires checking multiple cycles, and also requires the extra hardware of a second clock divider.</p>
<p>Finally, another method is to use a FSM with explicitly defined states for handling the clock jitter. This is essentially similar to what I do with the counter, but my counter logic is much simpler in my opinion.</p>
</section>
<section id="top-level-module" class="level3">
<h3 class="anchored" data-anchor-id="top-level-module">Top Level module</h3>
<p>For the top level module, I wanted to make sure that everything was wired correctly together, and that the keypad was controlling the digits as expected. We don’t need to go through every single state of all submodules because we have thuroughly tested them all independently. This is the value of having very little logic in the top level module itself, it is mainly wiring things together.</p>
</section>
<section id="module-resuse" class="level3">
<h3 class="anchored" data-anchor-id="module-resuse">Module Resuse</h3>
<p>I used multiple modules that I have used in lab 1 and lab 2, specifically the seven segment display module and the clock divider module. Because I have tested these thoroughly, I can use these as building blocks that I know work.</p>
</section>
<section id="eye-test" class="level3">
<h3 class="anchored" data-anchor-id="eye-test">Eye test</h3>
<p>For this type of project, the simple eye test is very important. Just because the verilog works as expected, we need to make sure that the chosen frequency for switching digits is fast enough to not notice flickering, but slow enough to not see any digits bleeding into each other. Additionally, it is difficult to know if the clock bounce protection works as intended until you use the physical keypad. Finally, the asyncronous inputs cannot really be simulated to test if they are metastable, so for all of this I needed to wait and see if it worked in hardware.</p>
</section>
</section>
<section id="technical-documentation" class="level2">
<h2 class="anchored" data-anchor-id="technical-documentation">Technical Documentation:</h2>
<p>The code for my project can be found on my github page. <a href="https://github.com/eoinoconnell04/E155-Lab3">Lab3 Github Repository</a></p>
<section id="block-diagram" class="level3">
<h3 class="anchored" data-anchor-id="block-diagram">Block Diagram</h3>
<p><img src="images/block_diagram.png" class="img-fluid"></p>
<figcaption>
Figure 1: Block Diagram of the Verilog design.
</figcaption>
<p>The block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module top includes three submodules: the high-speed oscillator block (HSOSC), the clock divider module (divider), and the seven segment display decoder (display).</p>
<p>It also includes a mux to switch between the two DIP switch input signals, an adder to sum together the input signals, and an inverter to create a set of opposing display control signals (when one is one the other is off and vice versa).</p>
</section>
<section id="schematic" class="level3">
<h3 class="anchored" data-anchor-id="schematic">Schematic</h3>
<p><img src="images/schematic.png" class="img-fluid"></p>
<figcaption>
Figure 2: Schematic of the Physical Circuit.
</figcaption>
<p>Figure 2 shows the physical layout of the design. I need resistors for the 7 segment display, and these remain the same from lab 2. The seven segment display has a typical forward voltage of 1.95 V (from datasheet), the PNP transistor has a Collector−Emitter Saturation Voltage of around 0.2 V, and given the 3.3 V input, we have an base voltage of <span class="math inline">\(3.3 - 1.95 - 0.2 = 1.15\)</span>. we get <span class="math inline">\(I = V/R = 1.15 / 330 = 3.48\)</span> mA. This is an acceptable current for the FPGA GPIO pins, and the seven segment display has a bright clear ouptut, so this is what was used.</p>
<p>Additionally, I need to calculate the resistor for the gate of the PNP transistor. From the data sheet, the Base−Emitter Saturation Voltage has a typical value of <span class="math inline">\(0.9\)</span> V. That means the base is sitting at <span class="math inline">\(3.3-0.9 = 2.4\)</span> V. My initial choice was a 2.2 k <span class="math inline">\(\Omega\)</span> resistor, which gives <span class="math inline">\(2.4/2200 = 1.09\)</span> mA through the FPGA pin. This is a perfectly acceptable FPGA current, and the transistor is operating correctly so it is used for this lab.</p>
<p>Finally, I needed pull-down resistors to make sure that the horizontal input pins to the FPGA are not floating when the button is not pressed. I was using pull-down resistors instead of pull-up resistors because my switches were wired in a way to be active high instead of active low. The resistor I used was 10 k <span class="math inline">\(\Omega\)</span>. This worked as intended so the value was kept. This is not a board safety resistor like the current limiting resistors, we would only need to change it if it was providing floating behavior that was not working as intended.</p>
</section>
<section id="fsm-diagrams-and-tables" class="level3">
<h3 class="anchored" data-anchor-id="fsm-diagrams-and-tables">FSM Diagrams and Tables</h3>
<p><img src="images/jitter_fsm.png" class="img-fluid"></p>
<p>Now we have the state transistion and output tables:</p>
<p><img src="images/jitter_fsm_table.png" class="img-fluid"></p>
<figcaption>
State transistion and output table for jitter FSM.
</figcaption>
<p><img src="images/counter_fsm_table.png" class="img-fluid"></p>
<figcaption>
State transistion and output table for counter FSM.
</figcaption>
<p>Note, for the count FSM the output is the same as the state itself, so a separate column is not shown.</p>
<p><img src="images/clk_phase_shifter_fsm_table.png" class="img-fluid"></p>
<figcaption>
State transistion and output table for clock phase shifter FSM.
</figcaption>
<p><img src="images/sync_fsm.png" class="img-fluid"></p>
<p>Here we see the internal flops inside the synchcronizer and store_keypresses modules. These look very similar in design but serve completely different functions. One is a synchcronizer and one is a shift register.</p>
</section>
</section>
<section id="results-and-discussion" class="level2">
<h2 class="anchored" data-anchor-id="results-and-discussion">Results and Discussion</h2>
<p>I accomplished all of the perscribed tasks: The keypad correctly inputs to the two digit seven segement display with no flickering, no switch bouce, and with all digits at an even brightness. The board remains functional when multiple inputs are pressed, and when a button is held and other buttons are pressed before it is released.</p>
<section id="testbench-simulation" class="level3">
<h3 class="anchored" data-anchor-id="testbench-simulation">Testbench Simulation</h3>
<p>The first testbench is to simulate the top level module. We can see the waveforms match the expected values. For this test, I modified the parameter TOGGLE_COUNT for the divider to make the divided clock only half the frequency of the regular clock. This allows for a much more managable testbench as we do not need to wait thousands of cycles for the divided_clk to flip.</p>
<p>To generate the long test vectors file for the top level module to have complete coverage of all input combinations, I wrote a short python script <code>generate_lab2_eo_testvectors.py</code> which loops through all input combinations and appends one cycle with the first digit illuminated, and a second cycle with the second digit, before moving to the next switch combination. This made it very easy to modify the test vectors as I developed the module itself, instead of working on a very large complex testvector file directly.</p>
<p><img src="images/lab3_eo_waveforms.png" class="img-fluid"></p>
<figcaption>
Figure 3: Top level module wave forms.
</figcaption>
<!--
In figure 3, we see that the expected and simulated waveforms match. Of course, this is only the first couple cycles, but this continuous for all 512 tests. The 512 tests covers all $2^8$ combinations of switches twice, as it includes 2 cycles per combination to allow the mux to select both inputs and flash the number on the respective panel.
-->
<p><img src="images/lab3_eo_tests.png" class="img-fluid"></p>
<figcaption>
Figure 4: Top level module testbench output.
</figcaption>
<!--
Figure 4 output also confirms that the 512 tests matched the expectation, including the LEDs, the seven segment display, and the display selection signals.
-->
<p><img src="images/display_tb.png" class="img-fluid"></p>
<figcaption>
Figure 5: Seven segment display module waveforms.
</figcaption>
<p>Here, we are using the exact same unmodified display module from lab1, and we have the same test bench to confirm it’s functionality. We test for all combinations of s, and ensure that the 7 bit binary output is as expected.</p>
<p><img src="images/display_tb_tests.png" class="img-fluid"></p>
<figcaption>
Figure 6: Seven segment display testbench output.
</figcaption>
<p>Figure 6 shows that all 16 possible combinations of s matched the expectation.</p>
<p><img src="images/divider_test_version_tb.png" class="img-fluid"></p>
<figcaption>
Figure 7: Test version of clock divider module waveforms.
</figcaption>
<p>Just like the seven segment display decoder, we are reusing the clock divider as well.</p>
<p>Here we can see that the test verison spends 10 cycles at zero and 10 cycles at one. This divides the frequency by 20. This testbench is much easier to keep track of then trying to simulate the clock divider counting thousands of cycles, yet still provides confirmation that it is working as intended.</p>
<p><img src="images/divider_test_version_tb_tests.png" class="img-fluid"></p>
<figcaption>
Figure 8: Test version of clock divider module testbench output.
</figcaption>
<p>Figure 8 gives confirmation that the module outputs match the expected values for all tests.</p>
<p><img src="images/clk_phase_shifter_waveforms.png" class="img-fluid"> <img src="images/clk_phase_shifter_tests.png" class="img-fluid"> <img src="images/jitter_controller_waveforms.png" class="img-fluid"> <img src="images/jitter_controller_tests.png" class="img-fluid"> <img src="images/keyboard_mapper_waveforms.png" class="img-fluid"> <img src="images/keyboard_mapper_tests.png" class="img-fluid"> <img src="images/onehot_waveforms.png" class="img-fluid"> <img src="images/onehot_tests.png" class="img-fluid"> <img src="images/store_keypresses_waveforms.png" class="img-fluid"> <img src="images/store_keypresses_tests.png" class="img-fluid"> <img src="images/sync_waveforms.png" class="img-fluid"> <img src="images/sync_tests.png" class="img-fluid"></p>
</section>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Lab 3 was quite difficult, but not that much worse than the previous labs. I spent around 4 hours writting verilog at home, and then around 10 hours in the lab writting testbenches, reviewing testbench results, modfing code, and making the design work on my hardware. Including the write up, the lab was around 17 hours in total.</p>
<p>The lab was succesfull as I was able to get everything to work as intended.</p>
<p>The most difficult part was figuring out why my keypad was not working when I build my breadboard circuit. I was not dividing my clock and I think this resulting in some hold time constraints that was causing some strange behavior on my keypad. Then I instantiated a second clock divider to slow down the keypad logic, but it caused everything to stop working completely. I think this was another timing issue, but I didn’t figure it out. I finally got it to work by changing a parameter on the high speed osciallator and running it at a naturally lower frequency.</p>
</section>
<section id="ai-prototype-summary" class="level2">
<h2 class="anchored" data-anchor-id="ai-prototype-summary">AI Prototype Summary</h2>
<blockquote class="blockquote">
<p><strong><em>Prompt A 1:</em></strong> Whole Lab (Monolithic) Write synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement: A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.</p>
</blockquote>
<p>I used my ChatGPT free account to create this, and all the files are contained in <a href="https://github.com/eoinoconnell04/E155-Lab3/blob/main/fpga/src/ai_prototype">here</a> on my github.</p>
<p>The monolithinc approach synthesized succesfully in radiant which really surprised me. The design actually broke it up into 3 modules and good documentation for each. I think that the much longer prompt with more detailed instruction is why this worked. Previous prompts were sometimes more like one sentence and thus the results were less accurate. This shows the importance of prompt engineering.</p>
<p>The part B of this was broken into multiple prompts, one for each module:</p>
<blockquote class="blockquote">
<p><strong><em>Prompt B 1:</em></strong> LLM Prompt 1: One‑shot Registration (Debounce‑by‑design) Overall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display. Current Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior: When a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here. For some reason, despite providing the files as context, the LLM did not use the correct port names when instantiating the modules. For example for the divider it used <code>clk_in</code> and <code>clk_out</code> instead of <code>clk</code> and <code>divided_clk</code> which my module uses. Likewise it used <code>in</code> and <code>out</code> for the seven segment display instead of <code>s</code> and <code>seg</code>. It also got the parameter name <code>TOGGLE_COUNT</code> wrong and called it <code>n</code>. Somehow it new what the inputs, outputs, and parameters were, but somehow did not copy over the names correctly.</p>
</blockquote>
<blockquote class="blockquote">
<p><strong><em>Prompt B 2:</em></strong> Target device: Lattice iCE40 UP5K FPGA. Write a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior: Iterate columns at a suitable scan rate derived from the divided clock and sample rows. When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches. I performed those manual changes, the design synthesized correctly. It got the oscillator correct, and the rest of the SystemVerilog code seems reasonable (but also not modular like Prompt 1 response).</p>
</blockquote>
<blockquote class="blockquote">
<p><strong><em>Prompt B 3:</em></strong> Integrate and Display Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source. Write a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements: Update the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.</p>
</blockquote>
<p>This design failed during the place and route, and crashed out of synthesis. This is because it got the module name wrong for the high speed oscillator. Instead of using <code>HSOSC</code>, it used <code>SB_HFOSC</code>. Despite this, on the surface level the modules seemed partitioned well. When I fixed this error, I got some more errors, including that there was an unknown module <code>sevenSegment</code> instead of <code>display</code> which is in the file I gave as context. After fixing this, more similar errors kept popping up so I stopped. Similar issue to the name issue I had for AI prototype in lab2.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/eoinoconnell04\.github\.io\/E155-Portfolio\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>