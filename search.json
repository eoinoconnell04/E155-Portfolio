[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab 4 Reflection\n\n\nWorking with MCUs in lab 4.\n\n\n\n\n\nSep 30, 2025\n\n\nEoin O’Connell\n\n\n\n\n\n\n\n\n\n\n\n\nLabs 1-3 Reflections\n\n\nReflecting on FPGA labs 1-3.\n\n\n\n\n\nSep 16, 2025\n\n\nEoin O’Connell\n\n\n\n\n\n\n\n\n\n\n\n\nInitial Reflections\n\n\nOverview of my background in digital design and goals in E155.\n\n\n\n\n\nAug 29, 2025\n\n\nEoin O’Connell\n\n\n\n\n\n\n\n\n\n\n\n\nE155 Kickoff\n\n\nWelcome to my E155 portfolio\n\n\n\n\n\nAug 28, 2025\n\n\nEoin O’Connell\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "E155-Project/project.html",
    "href": "E155-Project/project.html",
    "title": "Project: Real Time 3-Band EQ Filtering",
    "section": "",
    "text": "Project Proposal\n\n\nInteractive 3-Band EQ Simulator\n\n\nIIR Filter Math and Calculations"
  },
  {
    "objectID": "E155-Project/project.html#features",
    "href": "E155-Project/project.html#features",
    "title": "Project: Real Time 3-Band EQ Filtering",
    "section": "Features",
    "text": "Features\n\nThree adjustable bands:\n\nLow: ~100–400 Hz\nMid: ~400 Hz–2 kHz\nHigh: ~2–8 kHz\n\nReal-time digital filtering on an iCE40 UltraPlus FPGA\nMCU-controlled filter coefficients sent via SPI\nStereo input/output using I²S protocol\nBypass mode preserves original audio when knobs are neutral"
  },
  {
    "objectID": "E155-Project/project.html#hardware",
    "href": "E155-Project/project.html#hardware",
    "title": "Project: Real Time 3-Band EQ Filtering",
    "section": "Hardware",
    "text": "Hardware\n\niCE40 UltraPlus FPGA\nSTM32L432KC MCU\nPCM1808 ADC\nPCM5102 DAC\n3 x potentiometers for EQ control\nStandard 1/8-inch audio input"
  },
  {
    "objectID": "E155-Project/project.html#usage",
    "href": "E155-Project/project.html#usage",
    "title": "Project: Real Time 3-Band EQ Filtering",
    "section": "Usage",
    "text": "Usage\n\nConnect an audio source to the ADC.\nAdjust low, mid, and high potentiometers to modify EQ in real time.\nAudio output is sent to speakers via the DAC."
  },
  {
    "objectID": "E155-Project/bode_plot_demo.html",
    "href": "E155-Project/bode_plot_demo.html",
    "title": "Interactive 3-Band EQ Frequency Response Demo",
    "section": "",
    "text": "Low:  Mid:  High:"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "Labs",
    "section": "",
    "text": "Lab1: FPGA and MCU Setup and Testing\n\n\n\nLab 2: Multiplexed 7-Segment Display\n\n\n\nLab 3: Keypad Scanner\n\n\n\nLab 4: Digital Audio\n\n\n\nLab 5: Interrupts\n\n\n\nLab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "Labs",
    "section": "",
    "text": "Lab1: FPGA and MCU Setup and Testing"
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "Labs",
    "section": "",
    "text": "Lab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "Labs",
    "section": "",
    "text": "Lab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "Labs",
    "section": "",
    "text": "Lab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "Labs",
    "section": "",
    "text": "Lab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Labs",
    "section": "",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard\nLab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "E155 Kickoff",
    "section": "",
    "text": "Welcome to my E155 portfolio!"
  },
  {
    "objectID": "posts/initial_reflection.html",
    "href": "posts/initial_reflection.html",
    "title": "Initial Reflections",
    "section": "",
    "text": "This is my third digital design class at Harvey Mudd, starting with E85: Digital Electronics and Computer Engineering, followed by E154: System-on-Chip Design, and now E155: Microprocessor Systems Design and Application.\nLast summer I worked as a Physical Design intern at Tenstorrent, working on a RISC-V processor, so I am excited to get exposure to a completely different part of computer engineering, for very different applications.\nI expect this class to be quite challenging, particularly with time managament. My goals are to stay multiple days ahead of due dates—not my normal inclination—to avoid long nights and extra stress if possible.\nI am quite excited for a lot of the labs, particularly the 7 segment display lab, as well as the ditial audio lab. I think the 7 segment display is a very clear application that has a lot of uses, and I think it would be cool to connect multiple displays together to be able to print out longer messages. Additionally, as a musician, I am excited to work on the digital audio lab, and would be excited to expand this to include a keyboard.\nOverall, I am very excited to see where this class takes me."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "This lab aimed to build upon Labs 1 and 2 with clock multiplexing and seven segment displays, to build a keypad scanner that displays the last two digits pressed. This required dealing with clock bouncing, and asyncronous inputs."
  },
  {
    "objectID": "labs/lab3/lab3.html#introduction",
    "href": "labs/lab3/lab3.html#introduction",
    "title": "Lab 3: Keypad Scanner",
    "section": "",
    "text": "This lab aimed to build upon Labs 1 and 2 with clock multiplexing and seven segment displays, to build a keypad scanner that displays the last two digits pressed. This required dealing with clock bouncing, and asyncronous inputs."
  },
  {
    "objectID": "labs/lab3/lab3.html#design-and-testing-methodology",
    "href": "labs/lab3/lab3.html#design-and-testing-methodology",
    "title": "Lab 3: Keypad Scanner",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThis lab included a lot of separate parts that had to be tested independetly to have a working design. Thus, I created many submodules that could be independetly tested with testbenches. I wrote modules to deal with asyncronous inputs, and the rest of my design fully assumes that these inputs work as expected.\n\nClock Debouncing\nOne inherant problem of using physical switches is the problem of clock bouncing or jitter. This is a short period when the switch is first pressed when the physical contact vibrate and might not read a stable value. This would result in a single press being read as multiple key strokes, and could also complicate function when one key is held down and another is pressed immediately after.\nThe strategy that I used to deal with this problem was to keep track of a button that is pressed, and wait for a specified number of cycles before going back into a scanning mode. During these cycles, if the key is detected again, it resets the counter. Therfore, while a button is in a clock jitter phase or help down for a long time, the count will keep resetting and the system will stay in the active state and not return to the scanning state.\nThis has the advantages of detecting a keypress essentially instantaenously. Other strategies, such as a low-pass filter can cause significant delays in seeing a digit be recognized. Additionally, it combines the debouncing with the handling of simultaneous inputs or an input while a key is being held. This group of interacting FSMs does a lot of the heavy lifting to ensure correct functionality of the system. It also is able to do a good job of detecting the same button pressed multiple times (different to clock jitter, this is an actual human clicking a button multiple times) as once the set number of cycles without a button push is reached it is now scanning for new buttons, and this includes the same button that was just released.\nSimilar to the low-pass filter, another strategy would be to wait for a certain number of consecutive cycles to “agree” that a switch has been pressed. Even if the delay is minimal, this still requires a delay from a switch being pressed to being officially detected and displayed on the seven segment display. My method has the detection on the first leading edge of a new clock press, and handles the bounce on the backend instead of the frontend.\nAnother option is to slow the clock down significantly. My method allowed me to use a 6 MHz clock with no issues, and this made sure that everything was very responsive and quick. By dividing this clock this would also reduce the response time. This method still requires checking multiple cycles, and also requires the extra hardware of a second clock divider.\nFinally, another method is to use a FSM with explicitly defined states for handling the clock jitter. This is essentially similar to what I do with the counter, but my counter logic is much simpler in my opinion.\n\n\nTop Level module\nFor the top level module, I wanted to make sure that everything was wired correctly together, and that the keypad was controlling the digits as expected. We don’t need to go through every single state of all submodules because we have thuroughly tested them all independently. This is the value of having very little logic in the top level module itself, it is mainly wiring things together.\n\n\nModule Resuse\nI used multiple modules that I have used in lab 1 and lab 2, specifically the seven segment display module and the clock divider module. Because I have tested these thoroughly, I can use these as building blocks that I know work.\n\n\nEye test\nFor this type of project, the simple eye test is very important. Just because the verilog works as expected, we need to make sure that the chosen frequency for switching digits is fast enough to not notice flickering, but slow enough to not see any digits bleeding into each other. Additionally, it is difficult to know if the clock bounce protection works as intended until you use the physical keypad. Finally, the asyncronous inputs cannot really be simulated to test if they are metastable, so for all of this I needed to wait and see if it worked in hardware."
  },
  {
    "objectID": "labs/lab3/lab3.html#technical-documentation",
    "href": "labs/lab3/lab3.html#technical-documentation",
    "title": "Lab 3: Keypad Scanner",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe code for my project can be found on my github page. Lab3 Github Repository\n\nBlock Diagram\n\n\nFigure 1: Block Diagram of the Verilog design.\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module top includes three submodules: the high-speed oscillator block (HSOSC), the clock divider module (divider), and the seven segment display decoder (display).\nIt also includes a mux to switch between the two DIP switch input signals, an adder to sum together the input signals, and an inverter to create a set of opposing display control signals (when one is one the other is off and vice versa).\n\n\nSchematic\n\n\nFigure 2: Schematic of the Physical Circuit.\n\nFigure 2 shows the physical layout of the design. I need resistors for the 7 segment display, and these remain the same from lab 2. The seven segment display has a typical forward voltage of 1.95 V (from datasheet), the PNP transistor has a Collector−Emitter Saturation Voltage of around 0.2 V, and given the 3.3 V input, we have an base voltage of \\(3.3 - 1.95 - 0.2 = 1.15\\). we get \\(I = V/R = 1.15 / 330 = 3.48\\) mA. This is an acceptable current for the FPGA GPIO pins, and the seven segment display has a bright clear ouptut, so this is what was used.\nAdditionally, I need to calculate the resistor for the gate of the PNP transistor. From the data sheet, the Base−Emitter Saturation Voltage has a typical value of \\(0.9\\) V. That means the base is sitting at \\(3.3-0.9 = 2.4\\) V. My initial choice was a 2.2 k \\(\\Omega\\) resistor, which gives \\(2.4/2200 = 1.09\\) mA through the FPGA pin. This is a perfectly acceptable FPGA current, and the transistor is operating correctly so it is used for this lab.\nFinally, I needed pull-down resistors to make sure that the horizontal input pins to the FPGA are not floating when the button is not pressed. I was using pull-down resistors instead of pull-up resistors because my switches were wired in a way to be active high instead of active low. The resistor I used was 10 k \\(\\Omega\\). This worked as intended so the value was kept. This is not a board safety resistor like the current limiting resistors, we would only need to change it if it was providing floating behavior that was not working as intended.\n\n\nFSM Diagrams and Tables\n\nNow we have the state transistion and output tables:\n\n\nState transistion and output table for jitter FSM.\n\n\n\nState transistion and output table for counter FSM.\n\nNote, for the count FSM the output is the same as the state itself, so a separate column is not shown.\n\n\nState transistion and output table for clock phase shifter FSM.\n\n\nHere we see the internal flops inside the synchcronizer and store_keypresses modules. These look very similar in design but serve completely different functions. One is a synchcronizer and one is a shift register."
  },
  {
    "objectID": "labs/lab3/lab3.html#results-and-discussion",
    "href": "labs/lab3/lab3.html#results-and-discussion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI accomplished all of the perscribed tasks: The keypad correctly inputs to the two digit seven segement display with no flickering, no switch bouce, and with all digits at an even brightness. The board remains functional when multiple inputs are pressed, and when a button is held and other buttons are pressed before it is released.\n\nTestbench Simulation\nThe first testbench is to simulate the top level module. We can see the waveforms match the expected values. For this test, I modified the parameter TOGGLE_COUNT for the divider to make the divided clock only half the frequency of the regular clock. This allows for a much more managable testbench as we do not need to wait thousands of cycles for the divided_clk to flip.\nTo generate the long test vectors file for the top level module to have complete coverage of all input combinations, I wrote a short python script generate_lab2_eo_testvectors.py which loops through all input combinations and appends one cycle with the first digit illuminated, and a second cycle with the second digit, before moving to the next switch combination. This made it very easy to modify the test vectors as I developed the module itself, instead of working on a very large complex testvector file directly.\n\n\nFigure 3: Top level module wave forms.\n\n\n\n\nFigure 4: Top level module testbench output.\n\n\n\n\nFigure 5: Seven segment display module waveforms.\n\nHere, we are using the exact same unmodified display module from lab1, and we have the same test bench to confirm it’s functionality. We test for all combinations of s, and ensure that the 7 bit binary output is as expected.\n\n\nFigure 6: Seven segment display testbench output.\n\nFigure 6 shows that all 16 possible combinations of s matched the expectation.\n\n\nFigure 7: Test version of clock divider module waveforms.\n\nJust like the seven segment display decoder, we are reusing the clock divider as well.\nHere we can see that the test verison spends 10 cycles at zero and 10 cycles at one. This divides the frequency by 20. This testbench is much easier to keep track of then trying to simulate the clock divider counting thousands of cycles, yet still provides confirmation that it is working as intended.\n\n\nFigure 8: Test version of clock divider module testbench output.\n\nFigure 8 gives confirmation that the module outputs match the expected values for all tests.\nFigures 9-14 give confirmation that all the other submodules also perform their function as intended.\n \n\nFigure 9: Phase shifter module testbench output.\n\n \n\nFigure 10: Jitter Controller module testbench output.\n\n \n\nFigure 11: Keyboard mapper module testbench output.\n\n \n\nFigure 12: One hot decoder module testbench output.\n\n \n\nFigure 13: Store keypresses module testbench output.\n\n \n\nFigure 14: Synchcronizer module testbench output."
  },
  {
    "objectID": "labs/lab3/lab3.html#conclusion",
    "href": "labs/lab3/lab3.html#conclusion",
    "title": "Lab 3: Keypad Scanner",
    "section": "Conclusion",
    "text": "Conclusion\nLab 3 was quite difficult, but not that much worse than the previous labs. I spent around 4 hours writting verilog at home, and then around 10 hours in the lab writting testbenches, reviewing testbench results, modfing code, and making the design work on my hardware. Including the write up, the lab was around 17 hours in total.\nThe lab was succesfull as I was able to get everything to work as intended.\nThe most difficult part was figuring out why my keypad was not working when I build my breadboard circuit. I was not dividing my clock and I think this resulting in some hold time constraints that was causing some strange behavior on my keypad. Then I instantiated a second clock divider to slow down the keypad logic, but it caused everything to stop working completely. I think this was another timing issue, but I didn’t figure it out. I finally got it to work by changing a parameter on the high speed osciallator and running it at a naturally lower frequency."
  },
  {
    "objectID": "labs/lab3/lab3.html#ai-prototype-summary",
    "href": "labs/lab3/lab3.html#ai-prototype-summary",
    "title": "Lab 3: Keypad Scanner",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\nPrompt A 1: Whole Lab (Monolithic) Write synthesizable SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7‑segment display. Implement: A clock divider that derives a scan clock on the order of 100–200 Hz from the internal oscillator. A keypad scanning controller that iterates one active‑low column at a time and samples active‑low rows, registering at most one key per press (debounce‑by‑design), ignoring additional presses while any key is held, and allowing a new registration only after release. A top level that updates two hex digits (older and most recent) when a new key is registered and drives a time‑multiplexed two‑digit 7‑segment display without visible flicker and with balanced brightness. Use idiomatic SystemVerilog (e.g., logic, always_ff, enumerated states for FSMs). Provide clean module boundaries and keep all state synchronous. Include brief comments explaining the design choices.\n\nI used my ChatGPT free account to create this, and all the files are contained in here on my github.\nThe monolithinc approach synthesized succesfully in radiant which really surprised me. The design actually broke it up into 3 modules and good documentation for each. I think that the much longer prompt with more detailed instruction is why this worked. Previous prompts were sometimes more like one sentence and thus the results were less accurate. This shows the importance of prompt engineering.\nThe part B of this was broken into multiple prompts, one for each module:\n\nPrompt B 1: LLM Prompt 1: One‑shot Registration (Debounce‑by‑design) Overall Goal: Write SystemVerilog to scan a 4x4 matrix keypad and display the last two hex keys pressed on a dual 7 segment display. Current Goal: Write a synthesizable SystemVerilog module that produces a one‑shot registration signal for the keypad system. Behavior: When a key press is first detected, capture the current key code and assert a single‑cycle “new key” pulse. While any key remains pressed, do not accept additional keys. Only after keys are released should a subsequent press be recognized. This should handle debouncing of the keys. Implement as a small synchronous FSM with enumerated states and glitch‑free outputs. Keep names and interfaces reasonable; do not assume any hidden modules beyond what you define here. For some reason, despite providing the files as context, the LLM did not use the correct port names when instantiating the modules. For example for the divider it used clk_in and clk_out instead of clk and divided_clk which my module uses. Likewise it used in and out for the seven segment display instead of s and seg. It also got the parameter name TOGGLE_COUNT wrong and called it n. Somehow it new what the inputs, outputs, and parameters were, but somehow did not copy over the names correctly.\n\n\nPrompt B 2: Target device: Lattice iCE40 UP5K FPGA. Write a synthesizable SystemVerilog module that cycles through keypad columns (active‑low, one at a time) and samples rows (active‑low) to detect a single key at a time. Behavior: Iterate columns at a suitable scan rate derived from the divided clock and sample rows. When a key is detected, report a stable key code consistent with a standard 4x4 keypad layout and maintain it while the key remains pressed. Provide a boolean signal indicating whether any key is currently pressed. Use clean state encoding and synchronous logic; avoid combinational feedback and latches. I performed those manual changes, the design synthesized correctly. It got the oscillator correct, and the rest of the SystemVerilog code seems reasonable (but also not modular like Prompt 1 response).\n\n\nPrompt B 3: Integrate and Display Target device: Lattice iCE40 UP5K FPGA with internal oscillator as the root clock source. Write a top‑level SystemVerilog module that instantiates the scanner and one‑shot modules, shifts the last two keys (older ← most recent; most recent ← new), and drives a multiplexed two‑digit seven‑segment display. Requirements: Update the displayed digits only when a new key is registered. Ensure equal apparent brightness and no visible flicker. Keep all logic synthesizable and synchronous; use idiomatic SystemVerilog constructs. Provide any small clock‑enable or divider logic you need. You can also assume that a sevenSegment module exists that takes a 4 bit input and outputs the 7 segments.\n\nThis design failed during the place and route, and crashed out of synthesis. This is because it got the module name wrong for the high speed oscillator. Instead of using HSOSC, it used SB_HFOSC. Despite this, on the surface level the modules seemed partitioned well. When I fixed this error, I got some more errors, including that there was an unknown module sevenSegment instead of display which is in the file I gave as context. After fixing this, more similar errors kept popping up so I stopped. Similar issue to the name issue I had for AI prototype in lab2."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "This is the second Lab in E155 working with microcontrollers. The goal of this lab is to get comfortable with interrupts through designing an algorithm to sense quadrature encoder pulses and convert these into motor velocity and direction."
  },
  {
    "objectID": "labs/lab5/lab5.html#introduction",
    "href": "labs/lab5/lab5.html#introduction",
    "title": "Lab 5: Interrupts",
    "section": "",
    "text": "This is the second Lab in E155 working with microcontrollers. The goal of this lab is to get comfortable with interrupts through designing an algorithm to sense quadrature encoder pulses and convert these into motor velocity and direction."
  },
  {
    "objectID": "labs/lab5/lab5.html#design-and-testing-methodology",
    "href": "labs/lab5/lab5.html#design-and-testing-methodology",
    "title": "Lab 5: Interrupts",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe primary challenges of this lab are in the setup of the interrupts themselves. There are 4 possible interrupts, a rising or falling edge at A, or a rising or falling edge at B. This gives us all the information we need to be able to determine both velocity and direction.\n\nInterrupt Based Code vs Polling Based Code\nInterrupts are better than manual polling because they allow the microcontroller to respond immediately to encoder signal changes without constantly checking pin states in a loop. This makes the system far more efficient, as the CPU can perform other tasks while waiting for events instead of wasting cycles on continuous polling. At high speeds, interrupts also ensure more accurate and reliable pulse detection, since polling may miss transitions that occur faster than the loop’s execution rate.\nTo have correct data, we need to satisfy the Shannon-Nyquist theorem that \\(f_{sample} \\geq 2 * f_{max}\\). For manual polling, we need to pick a sampling rate and if the frequency of the motor hits a certain threshold then we will have aliasing, where it will read a lower frequency.\nInterrupt servicing is almost always much faster than polling loops, meaning that we can detect a much higher max frequency before aliasing or any other issues arise.\nTo test this, I created 2 different versions of my code, one with manual polling and one with interrupt based polling. Our power supplies go up to 20 V, and the motors can only handle around up to 24 V according to the data sheet, so 20 V is the maximum voltage I ran them at. At this speed, I was getting around 5 RPM. For both the polling and interrupt methods, this was a low enough speed that they were missing no edges, and thus no alliasing was observed. Eventually, the polling will hit it’s threshold before interrupts, but for a low speed application like this both are completely accaptable.\n\n\nFrequency Generator Tests\nBecause the motor only goes up to around 5 RPM, we were not able to reach the threshold for aliasing either the interrupt or polling based methods. To push artificially higher loads, I used a square wave function generator set to 50% duty cycle, to simulate one of the quadrature encoder pins toggling.\nFor this testing, I grounded one of the typical pins, and only used one of the pins (so we do not have direction data, but can test max frequency). I adjusted the frequency formulas to account for half as many interrupts / edges. Therefore, we are strictly measuring how fast the interrupts can measure edges vs how fast the polling method can detect a change in the pin value. For both of these methods, I kept the the calculations and printouts to be fair. Thus, it is not the fastest possible interrupt or the fastest possible polling (as I could make the ISR or the polling loop shorter), but it is a reasonable test for interrupts and polling in a real application such as this.\n\nFunction Generator Testing Note:\nNote, because I am using only one pin, this frequency will represent double the max RPM readable using the motor, as only one pin is toggling instead of two. With two pins, we get twice the interrupts, and we will start getting issues at half the rate. Thus, for this testing, the printed frequency is DOUBLE what we could achieve with a motor.\n\n\n\nFigure 1: MCU Output with function generator set to 19.1 Khz Using Interrupt Method.\n\nFigure 1 shows a steady output of 47.13 Hz. There is no aliasing present. This is the maximum frequnecy that I could get a stable reading at, above this some slight aliasing occured, with the effect getting worse as I increased frequency.\n\n\nFigure 2: MCU Output with function generator set to 19.1 Khz Using Polling Method.\n\nHere, I used my polling based method, but at the maximum frequency that I used for the polling based method. Here we see very severe aliasing, and we have unusable data. We still see a majority of datapoints showing the correct value, but we have some higher and some lower, and lots of noise.\nThe polling based method stopped being stable around 12 KHz on the function generator. This explains why we did not see any issues with the motor at 20V, as this is equivalent to the motor at 14 RPM, which is way more than the ~5 RPM of the motor. If the motor was above 14 RPM, we would see issues with the polling method but not the interrupt method (up to a point).\nIn conclusion, I would be able to detect a motor moving to around 23 RPM using the interrupt based method without having any aliasing effects, but would start having problems at 14 RPM using the polling based method.\n\n\nFlow Chart\nMy program uses an infinity loop consisting of a busy wait that is exited due to interrupts signalling a change in pin A or pin B. Then it does some calculations and measurements before entering the busy state again.\n\n\nFigure 3: Flow Chart of Interrupts and Main Loop Interactions.\n\n\n\nSegger Testing\nBefore ever flashing the MCU or connecting the motor, I tested my code in Segger Embedded Studio, loaded with drivers and packages for my STM32L432KC MCU. This allowed me to test that my code was working as intended. I looked into the relevant registers ensure that the timers were working as intended.\n\n\nFrequency and Direction Calculations\n\nFrequency\nTo measure the frequency I measure the time between two interrupts using a timer. The timer runs off the 80 MHz PLL, with a prescaler of 79 to give a 1 Mhz clock.\n\\[f_{\\text{motor}} = \\frac{f_{\\text{timer}}}{(\\text{\\# of cycles between edges}) \\times \\text{PPR} \\times \\text{(\\# of edges)}}\\]\nThe motor in lab has \\(PPR = 408\\), and there are 4 edges (rising and falling edges at A and B). Thus we get the following equation:\n\\[f_{\\text{motor}} = \\frac{f_{\\text{timer}}}{(\\text{\\# of cycles between edges}) \\times 1,632}\\]"
  },
  {
    "objectID": "labs/lab5/lab5.html#technical-documentation",
    "href": "labs/lab5/lab5.html#technical-documentation",
    "title": "Lab 5: Interrupts",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe code for my project can be found on my github page. Lab5 Github Repository\n\nSchematic\n\n\nFigure 4: Schematic of the Physical Circuit.\n\nFigure 4 shows the physical layout of the design. It shows the microcontroller Pin 6, which has the audio output, first going through a 50 k\\(\\Omega\\) potentiometer to be able to adjust the volume. Then this output goes into the LM386 audio amplifier. By connecting 5V to pin 6, ground to pin 2, and the input to pin 3, and not connection any other pins, we get a gain of 20. This allows us to get a higher voltage output then would have been possible then straight out of the MCU.\nFinally, the amplifier output goes to a 8 W, 4 \\(\\Omega\\) speaker."
  },
  {
    "objectID": "labs/lab5/lab5.html#results-and-discussion",
    "href": "labs/lab5/lab5.html#results-and-discussion",
    "title": "Lab 5: Interrupts",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI accomplished all of the perscribed tasks: The microcontroller correctly measures the velocity and direction of the motor. It works at low and high speeds, and outputs 0 frequency when the motor is stopped.\n\nExample Interrupt Based Output\nHere is an example output of what the MCU displays when the motor is running at around 10V. From the professor, we expect around 2 RPM at 10V. We can see that we are getting 2.2-2.3 RPM, so our motor is reading values that are reasonably correct. This shows that we are not missing edges and that we are getting accurate readings.\n\n\nFigure 5: Example MCU Output (Motor Running at 10V).\n\nWe can see in Figure 5 that the output is not a smooth number as we would expect, there is a lot of data point to data point variation. I wanted to output the most recent data point for maximum resolution, but this introduces a lot of noise. In reality, the motor is not spinning perfectly even, there are points of more and less resistance. When you sample this often through having an interrupt on every edge, some will be slighly shorter or and longer than others. Additionally, this method relies on the points in the motor being even spread out, but there is slight variation which also introduces noise.\nIn practice, I would introduce a moving average that takes the average \\(\\Delta T\\) from the last N samples to get a smoother measurement, but I didn’t incorporate this to satisfy the requirements of the lab.\n\n\nExample Polling Based output\n\n\nFigure 6: Example Polling Based MCU Output (Motor Running at 20V).\n\nIn figure 6, we can see the output of the polling based method, with the motor running at 20V (my maximum). Even at this high speed we do not miss any edges. This shows that both methods are valid for these reasonable speeds."
  },
  {
    "objectID": "labs/lab5/lab5.html#conclusion",
    "href": "labs/lab5/lab5.html#conclusion",
    "title": "Lab 5: Interrupts",
    "section": "Conclusion",
    "text": "Conclusion\nLab 5 was pretty difficult for me compared to other labs, due to me having no experience with interrupts, and spending a lot of time just trying to get my first interrupt to register. Once I was able to detect an edge, it was only a few more hours to iron out some bugs with my frequency calculations, and dealing with a stopped motor. Overall, it took about 22 hours in total, including getting the polling method to work and finalize all testing and documentation.\nThe lab was succesfull as I was able to get everything to work as intended."
  },
  {
    "objectID": "labs/lab5/lab5.html#ai-prototype-summary",
    "href": "labs/lab5/lab5.html#ai-prototype-summary",
    "title": "Lab 5: Interrupts",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\nLLM Prompt:\nWrite me interrupt handlers to interface with a quadrature encoder. I’m using the STM32L432KC, what pins should I connect the encoder to in order to allow it to easily trigger the interrupts?\n\nvoid Encoder_GPIO_Init(void) {\n    RCC-&gt;AHB2ENR |= RCC_AHB2ENR_GPIOAEN;\n    GPIOA-&gt;MODER &= ~((3 &lt;&lt; (0*2)) | (3 &lt;&lt; (1*2))); // input mode\n\n    // Enable EXTI lines 0 and 1\n    RCC-&gt;APB2ENR |= RCC_APB2ENR_SYSCFGEN;\n    SYSCFG-&gt;EXTICR[0] |= 0x0000; // PA0-&gt;EXTI0, PA1-&gt;EXTI1\n\n    EXTI-&gt;IMR1 |= (1 &lt;&lt; 0) | (1 &lt;&lt; 1);\n    EXTI-&gt;RTSR1 |= (1 &lt;&lt; 0) | (1 &lt;&lt; 1);\n    EXTI-&gt;FTSR1 |= (1 &lt;&lt; 0) | (1 &lt;&lt; 1);\n\n    NVIC_EnableIRQ(EXTI0_IRQn);\n    NVIC_EnableIRQ(EXTI1_IRQn);\n}\n\nvolatile int32_t position = 0;\n\nvoid EXTI0_IRQHandler(void) {\n    if (EXTI-&gt;PR1 & (1 &lt;&lt; 0)) {\n        EXTI-&gt;PR1 |= (1 &lt;&lt; 0);\n        int b = (GPIOA-&gt;IDR & (1 &lt;&lt; 1)) ? 1 : 0;\n        position += (b ? -1 : 1);\n    }\n}\n\nvoid EXTI1_IRQHandler(void) {\n    if (EXTI-&gt;PR1 & (1 &lt;&lt; 1)) {\n        EXTI-&gt;PR1 |= (1 &lt;&lt; 1);\n        int a = (GPIOA-&gt;IDR & (1 &lt;&lt; 0)) ? 1 : 0;\n        position += (a ? 1 : -1);\n    }\n}\nI used ChatGPT for my AI reflection, and it used pins A0 and A1, which could be done but they are not pins that have external interfaces on the ribbon cable. Because there are only two wires which directly connect to the motor, I could have connected leads directly from MCU to the motor. Picking these pins makes the code slighly simpler, as it breaks the ISR into 2 different handlers, one for each pin. My handler has to detect which pins caused the issue.\nAs for the logic of the quadrature, the AI didn’t convert from cycles to time, but this requires external knowledge about the configuration of the timer. It would be relatively simple to convert position to timing."
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "This is the third Lab in E155 working with microcontrollers. The goal of this lab is to implement an internet-accessible device to control an onboard LED and measure ambient temperature. It uses an ESP8266 with the provided web server code to host the webpage and use the onboard MCU GPIO and SPI peripherals to toggle an LED and to read temperature from a DS1722 temperature sensor. Users can turn the LED ON and OFF and view the current temperature from the webpage."
  },
  {
    "objectID": "labs/lab6/lab6.html#introduction",
    "href": "labs/lab6/lab6.html#introduction",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "",
    "text": "This is the third Lab in E155 working with microcontrollers. The goal of this lab is to implement an internet-accessible device to control an onboard LED and measure ambient temperature. It uses an ESP8266 with the provided web server code to host the webpage and use the onboard MCU GPIO and SPI peripherals to toggle an LED and to read temperature from a DS1722 temperature sensor. Users can turn the LED ON and OFF and view the current temperature from the webpage."
  },
  {
    "objectID": "labs/lab6/lab6.html#design-and-testing-methodology",
    "href": "labs/lab6/lab6.html#design-and-testing-methodology",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe primary challenge of this lab is to interface with periferals with different protocols, such as USART and SPI. I wrote custom drivers for my MCU to communicate with the wifi and temperature sensor chips, configured for their specific parameters.\n\nSegger Testing\nBefore ever flashing the MCU or connecting to the temperature or wifi sensors, I tested my code in Segger Embedded Studio, loaded with drivers and packages for my STM32L432KC MCU. This allowed me to test that my code was compiling and had no syntax errors.\n\n\nOscilloscope Logic Analyzer\nIn order to debug my SPI connection, I used the logic analyzer function on an oscilloscope. Before this, I was always getting a temperature reading of zero, as I was never getting anything back from the temperature sensor. This helped me realize I was not triggering the chip select on my set precision, along with a few other issues.\nWith the logic analyzer’s help, I was able to confirm that my SPI transactions were working as intended.\n\n\nFigure 1: Example SPI Transcation on Logic Analyzer.\n\nHere we first see the precision being set to 12 bits, in the first two packets on information shows on MOSI at the bottom of the screen. The first packet 0x80 is the address, and 0xE8 is the precision. This is followed by a readTemp() call, which provides the MSB packet followed by the LSB packet. The address for MSB and LSB and 0x02 and 0x01, respectively, and this returned the current temperature."
  },
  {
    "objectID": "labs/lab6/lab6.html#technical-documentation",
    "href": "labs/lab6/lab6.html#technical-documentation",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe code for my project can be found on my github page. Lab6 Github Repository\n\nSchematic\n\n\nFigure 2: Schematic of the Physical Circuit.\n\nFigure 2 shows the physical layout of the design."
  },
  {
    "objectID": "labs/lab6/lab6.html#results-and-discussion",
    "href": "labs/lab6/lab6.html#results-and-discussion",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI accomplished all of the perscribed tasks: The microcontroller correctly measures communicates via SPI to the temperature sensor, and publishes the current value on the website.\nFrom the website, you can update the precision, and change the LED status."
  },
  {
    "objectID": "labs/lab6/lab6.html#conclusion",
    "href": "labs/lab6/lab6.html#conclusion",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "Conclusion",
    "text": "Conclusion\nI spent around 13 hours on this lab. A few hours was writting the differnet drivers and doing inital work before testing. Next came getting the website to run on the MCU. I ran into a lot of html issues, and MCU issues on this, so it took a few hours to get it to work.\nFinally, the main amount of time was debugging the temperature sensor itself. I had to learn how to use the logic analyzer, and spent a long time getting it to work. Xavier was a huge help in debugging this.\nI found this to be the second hardest lab so far, only after lab 3. I am much more comfortable using test benches to debug before doing anything in the real world, but this lab really required benchtop debugging with the logic analyzer. I am very happy to have worked on these skills."
  },
  {
    "objectID": "labs/lab6/lab6.html#ai-prototype-summary",
    "href": "labs/lab6/lab6.html#ai-prototype-summary",
    "title": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\nLLM Prompt 1:\nI’m making a web portal to interface with a temperature sensor. Create a HTML page that looks good and is intuitive to show the temperature, control an LED, and change the precision of the readout.\n\nHere, the AI did a really good job, it implemented the following website, and all the buttons worked smoothly and as expected. This highlighted the strength that AI models have in front end development. My website is very barebones, with the default html buttons and no style at all. With just a few seconds, I can use AI to make my websites much better, and this is a very low risk use. Generally, as long as the website works and looks good, it is hard for the AI to have introduced any major issues through hallucination.\n\n\nFigure 3: AI Prototype HTML page.\n\n\nLLM Prompt 2:\nWrite me a C function to carry out a SPI transaction to retrieve a temperature reading from a DS1722 sensor. Make use of CMSIS libraries for the STM32L432KC.\n\nFor writing this library, the AI needed some more guidance. It referenced some fields that are not being recongized and will not compile. Potentially through including more #include statements this could work."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "This lab aimed to gain familiarity with the FPGA and MCU, and creating a simple seven segment display, as well as controlling some other LED functions."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "This lab aimed to gain familiarity with the FPGA and MCU, and creating a simple seven segment display, as well as controlling some other LED functions."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThis lab consisted of two main challenges, creating a blinking light at 2.4 Hz, and a seven segment display illuminating hexadecimal digits as specified by 4 dip switches.\n\nBlinking LED\nThe on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 48 MHz. Then, a counter was used to divide the high frequency clock signal down to 2.4 Hz specifically. The most simple clock dividers have a counter that overflows, and this makes it simple to divide the frequency by powers of two. Because 2.4 Hz, does not satisfy that for 48 Mhz, we need to establish the specific number of cycles that it takes take the perfect amount of time.\nMy design divided the clock frequency to 4.8 Hz, so that the LED would have a 50% duty cycle and a 2.4 Hz overall frequency. I used the equation: n * 1/48,000,000 = 1/4.8. Then, n = 48,000,000/4.8 = 10,000,000. Because the count starts at zero, I will keep increasing the count each cycle until it reaches 9,999,999, and then I will reset it for the next cycle and switch the LED from on to off, or from off to on.\nTo test this, I connected the LED prong to an oscilloscope, and measured the frequency. The measured frequency was 2.402 Hz, confirming the design’s function.\n\n\nSeven Segment display\nThe goal was to use the 4 input DIP switches to control the seven segment display, and ensure that all digits were unique (ex: 6 and b must be distinguishable). The first step was to map each hexadeciaml digit to the seven segment display and determine which panels should be on. Then, this was implemented using a case statement in SystemVerilog which turned the truth table into hardware.\n\n\nTestbenches\nBoth the top level module and the seven segment display module have automatic testbenches to check all possible permutations of input s[3:0], the 4 DIP switches. This simulates the output to make sure that the verilog has the expected functionality in all cases.\nAdditionally, I created a testbench for a modified version of the divider module (divider_test_version), which instead of dividing a clk frequency by 20,000,000, it divides it by 20. This will check that the module works as expected, while still being managable (doesn’t require simulating millions of clock cycles to check if a single bit changed).\n\n\nVisual test\nThe seven segment display and LEDs are also most easily tested through the simple eye test. By going through all 16 combinations of the DIP switches, I can confirm that all hexadecimal digits are shown and distinct, and that the two LEDs that are a function of the swtiches work as correctly, and that the third LED blinks at around 2.4 Hz. Of course, this is a supplement to more rigorous tests, but this is quite effective at detecting bugs that could be common in both the SystemVerilog and the testvectors, because a lot of the cases were copied from one to the other."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe code for my project can be found on my github page. Lab1 Github Repository\n\nBlock Diagram\n\n\nFigure 1: Block Diagram of the Verilog design.\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module top includes three submodules: the high-speed oscillator block (HSOSC), the clock divider module (divider), and the seven segment display decoder (display).\n\n\nSchematic\n\n\nFigure 2: Schematic of the Physical Circuit.\n\nFigure 2 shows the physical layout of the design. Note that led[3:0] have pins that were on the ribbon connector ports so that they could be passed to external LEDs on the breadboard due to a supply shortage of SMT diodes. Each led has a 1k \\(\\Omega\\) current-limiting resistor to ensure the output current, ~2.6 mA, does not exceed the maximum current rating for the FPGA GPIO pins.\nTo calculate the pull down resistors for the seven segement display, I used the datasheet of the display itself. This I chose to use 1k \\(\\Omega\\) as it was over the minimum safe resitance value and still provided a very bright display. Using a larger resistor in this case will only make the circuit safer, it just could reduce the brightness (even to the point of the LED not illuminating).\nI was powering the LED with 3.3 V, and the seven segment display has a typical forward voltage of 1.95 V. That means that we need to dissipate up to 1.35 V through the resistor. My starting point for choosing the resistance was to use 1k \\(\\Omega\\) resistors, just like the on board LEDs. Using V = I*R, I get \\(I = V/R = 1.35 / 1000 = 1.35\\) mA. This is an acceptable current for the FPGA GPIO pins, so this is the resistor value that I choose."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI accomplished all of the perscribed tasks: the standalone LEDs function as expected and the seven segement display shows all 16 hexadecimal digits, all controlled by the 4 DIP switches. For the 2.4 Hz pulsing LED, my oscilloscope measured 2.402 Hz frequency, but there was quite a bit of noise on the rising and falling edge of the signal. I am not sure if this small error is a measure effect, or perhaps it is comming from the oscillator itself. Regarless, this shows that the clock divider circuit is working as intended, with very minimal error.\n\nTestbench Simulation\nThe first testbench is to simulate the top level module. We can see the waveforms match the expected values. Note that for the simulation led[2] is floating because the oscillator is commented out because it cannot be simulated. Therefore, the expected output is led[1:0] appended in front of seg, giving us a 9 digit expected output.\n\n\nFigure 3: Top level module wave forms.\n\nNot only do we see the wave forms match, but we get a printout that all 16 possible permutations tests passed.\n\n\nFigure 4: Top level module testbench output.\n\nSimilarly for simulating the seven segment display module, we give the input switches s, and see the output seg matches the expected values.\n\n\nFigure 5: Seven segment display module waveforms.\n\nAgain, all 16 possible combinations of s matched the expectation.\n\n\nFigure 6: Seven segment display testbench output.\n\n\n\nFigure 7: Test version of clock divider module waveforms.\n\nHere we can see that the test verison spends 10 cycles at zero and 10 cycles at one. This divides the frequency by 20. This testbench is much easier to keep track of then trying to simulate the clock divider that counts to 10,000,000, as you would need to simulate so many more cycles just to see a change in the divided_clk signal.\nHere we can see that by counting to 10 for both the LED being on and off yeilds a total reduction in frequency by a factor of 20. Thus, by counting to 10,000,000, we get a frequency reduction by a factor of 20,000,000. That brings our 4.8 MHz clock to 2.4 Hz.\n\n\nFigure 8: Test version of clock divider module testbench output.\n\nJust like how the waveforms for the divided_clk and expected signals match, we get confirmation that all tests passed by the testbench output."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nI worked on this lab for three consecutive days, totalling around 15 hours. This included around 3 hours to solder the board and get setup, a few hours working on the demos, before working on the project itself. Writting the verilog only took about 45 minutes, as the idioms are quite simple once you understand the clock divider logic. I spent around 3 hours writing up the report and making diagrams.\nThe FPGA succesfully controlled both the seven segment display as well as the 3 standalone LEDs. The first two LEDs perform the XOR and AND functions correctly, and the third LED blinks at 2.4 Hz as desired.\nThe main assignment issue was simply a shortage of parts, which made certain functions more difficult to implement and test. For me, this meant that I had no on-board LEDs so I will have to solder and test these at a later date. For the assignment itself, I found it straightforward."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\nPrompt: Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\nThe code generated by ChatGPT base free model, which I believe to be GPT-5 but the website does not specify for my free acount. The file can be viewed here on my github.\nThe first thing I was impressed by was that the AI seemed to get the clock oscillator correct. Here you can see the difference between my code and the AI output from the simple prompt.\nAI Clock Generation:\nHSOSC #(\n        .CLKHF_DIV(\"0b00\")   // 48 MHz (00), 24 MHz (01), 12 MHz (10), 6 MHz (11)\n    ) hf_osc_inst (\n        .CLKHF(clk_hf),\n        .CLKHFEN(1'b1),      // enable output\n        .CLKHFPU(1'b1)       // power up oscillator\n    );\nMy Clock generation (from lab1 source code):\nHSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk));\nFurthermore, the clock divider function was very simple and similar to what I would have wrote:\n// Counter divider\n    logic [24:0] counter;   // enough bits for ~0.5s interval at 48 MHz\n    logic led_reg;\n\n    always_ff @(posedge clk_hf) begin\n        counter &lt;= counter + 1;\n\n        // Toggle LED at ~2 Hz (0.5s high, 0.5s low)\n        if (counter == 24_000_000) begin\n            led_reg &lt;= ~led_reg;\n            counter &lt;= 0;\n        end\n    end\nFor the clock to get down to 2 Hz, my math is that n * 1/48,000,000 = 4 (2 times the clock frequency so that the duty cycle is 50% and the overall frequncy is 2 Hz). This means that it should count 12,000,000 cycles before flipping. The way the AI did it was that the overall frequency is 1 Hz because it spends 0.5s high and 0.5s low, which is 1 Hz as each cycle takes 1 s.\nBesides that minor misunderstanding, I was quite impressed by the AI output.\nWhen I synthesized the AI ouput in Radiant, it compiled and synthesized with no errors on the very first try. I think that with slightly more guidance on the clock divider instructions, then this would work as expected.\nI was using Cursor extensively over the summer at my internship at Tenstorrent, and I found it extremely powerful because it has context of your other files and you don’t need to copy and paste back and forth from a website. I will try to get a student license, but the first half of this course is no AI allowed, so I will only be able to use it on the project."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "This lab aimed to gain familiarity with clock multiplexing and PNP transistors, through driving 2 seven segment displays with a single set of GPIO pins that rapidly switches back and forth at the same frequency as the power driving both displays. This gives the illusion that both are on simultaenously because our eyes cannot detect how fast the displays are switching on and off."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "This lab aimed to gain familiarity with clock multiplexing and PNP transistors, through driving 2 seven segment displays with a single set of GPIO pins that rapidly switches back and forth at the same frequency as the power driving both displays. This gives the illusion that both are on simultaenously because our eyes cannot detect how fast the displays are switching on and off."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThis challenge of this lab was using a single seven segment display module, and a corresponding single set of 7 GPIO pins to control two different seven segment display panels with different numbers. The trick is to rapidly switch the signals on outputed by the pins, and at the same frequency change which display gets power. That gives the illusion that both segements are continuously illuminated, but in reality it is only ever one at a time. This requires some testing to make sure that all the parts work together as intended.\n\nSeven Segment display\nThe display module takes a 4 bit signal and decodes it to control the seven segment display, ensuring that all digits were unique (ex: 6 and b must be distinguishable). The first step was to map each hexadeciaml digit to the seven segment display and determine which panels should be on. Then, this was implemented using a case statement in SystemVerilog which turned the truth table into hardware. This module was already tested in lab 1, and comfirmed with a testbench, so we can be sure that this module works as expected.\n\n\nClock divider\nLikewise, the clock divider was used in lab 1 as well. The parameter that changes the TOGGLE_COUNT was modified to output a faster frequency than lab 1 so that the human eye cannot detect flickering, but it is otherwise unchagned. Again this has it’s own testbench to ensure proper functionality, but we can also use this knowing that it works correctly.\n\n\nTop Level module\nSimulating the top level module was probably the most challenging aspect of all of lab 2. I changed the TOGGLE_COUNT parameter to flip every cycle (halving the clock frequency), so that the wave forms were more managable. Next, the challenge was getting testvector coverage for all \\(2^8\\) combinations of input switches, and also ensuring that the control signals that turn each one on or off were lined up correctly. To do this, I wrote a python script that generated these test vectors so they didn’t have to be hand written. This made it very easy to modify the testvectors as I identified bugs and changed the functionality of the module (it took me a few iterations to get the top level module outputs correct).\nThis module also tests the mux and adder logic, and this is built into the testvectors.\n\n\nEye test\nFor this type of project, the simple eye test is very important. Just because the verilog works as expected, we need to make sure that the chosen frequency for switching digits is fast enough to not notice flickering, but slow enough to not see any digits bleeding into each other."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe code for my project can be found on my github page. Lab2 Github Repository\n\nBlock Diagram\n\n\nFigure 1: Block Diagram of the Verilog design.\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module top includes three submodules: the high-speed oscillator block (HSOSC), the clock divider module (divider), and the seven segment display decoder (display).\nIt also includes a mux to switch between the two DIP switch input signals, an adder to sum together the input signals, and an inverter to create a set of opposing display control signals (when one is one the other is off and vice versa).\n\n\nSchematic\n\n\nFigure 2: Schematic of the Physical Circuit.\n\nFigure 2 shows the physical layout of the design. We have 5 leds on the breadboard controlled by led[4:0], and these have current limiting resistors. The green LEDs that I am using have a voltage drop around 2.2 volts, so the current through the resistor is \\(V/R = (3.3 - 2) / 330 = 3.9\\) mA. This is an acceptable current for the FGPA pins. I used 1k \\(\\Omega\\) resistors in lab1 and the LEDs were quite dim so I wanted to to have a brighter LED that was still safe for the FGPA in lab 2.\nAdditionally, I need resistors for the 7 segment display. In lab 1 I had current limiting resistors, but they were wired incorrectly and were not functioning as intended. Here I fixed that issue, but the calculation is the same from lab 1. The seven segment display has a typical forward voltage of 1.95 V (from datasheet), the PNP transistor has a Collector−Emitter Saturation Voltage of around 0.2 V, and given the 3.3 V input, we have an base voltage of \\(3.3 - 1.95 - 0.2 = 1.15\\). we get \\(I = V/R = 1.15 / 330 = 3.48\\) mA. This is an acceptable current for the FPGA GPIO pins, and the seven segment display has a bright clear ouptut, so this is what was used.\nFinally, I need to calculate the resistor for the gate of the PNP transistor. From the data sheet, the Base−Emitter Saturation Voltage has a typical value of \\(0.9\\) V. That means the base is sitting at \\(3.3-0.9 = 2.4\\) V. My initial choice was a 2.2 k \\(\\Omega\\) resistor, which gives \\(2.4/2200 = 1.09\\) mA through the FPGA pin. This is a perfectly acceptable FPGA current, and the transistor is operating correctly so it is used for this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI accomplished all of the perscribed tasks: the 5 standalone LEDs display the sum of the two hexadecimal digits as expected, and the two digit seven segement display shows both digits with no flickering, with all digits at an even brightness. This is controlled by the 4 dip switches on the board, as well as a secondary set of dip switches on the breadboard.\n\nTestbench Simulation\nThe first testbench is to simulate the top level module. We can see the waveforms match the expected values. For this test, I modified the parameter TOGGLE_COUNT for the divider to make the divided clock only half the frequency of the regular clock. This allows for a much more managable testbench as we do not need to wait thousands of cycles for the divided_clk to flip.\nTo generate the long test vectors file for the top level module to have complete coverage of all input combinations, I wrote a short python script generate_lab2_eo_testvectors.py which loops through all input combinations and appends one cycle with the first digit illuminated, and a second cycle with the second digit, before moving to the next switch combination. This made it very easy to modify the test vectors as I developed the module itself, instead of working on a very large complex testvector file directly.\n\n\nFigure 3: Top level module wave forms.\n\nIn figure 3, we see that the expected and simulated waveforms match. Of course, this is only the first couple cycles, but this continuous for all 512 tests. The 512 tests covers all \\(2^8\\) combinations of switches twice, as it includes 2 cycles per combination to allow the mux to select both inputs and flash the number on the respective panel.\n\n\nFigure 4: Top level module testbench output.\n\nFigure 4 output also confirms that the 512 tests matched the expectation, including the LEDs, the seven segment display, and the display selection signals.\n\n\nFigure 5: Seven segment display module waveforms.\n\nHere, we are using the exact same unmodified display module from lab1, and we have the same test bench to confirm it’s functionality. We test for all combinations of s, and ensure that the 7 bit binary output is as expected.\n\n\nFigure 6: Seven segment display testbench output.\n\nFigure 6 shows that all 16 possible combinations of s matched the expectation.\n\n\nFigure 7: Test version of clock divider module waveforms.\n\nJust like the seven segment display decoder, we are reusing the clock divider as well.\nHere we can see that the test verison spends 10 cycles at zero and 10 cycles at one. This divides the frequency by 20. This testbench is much easier to keep track of then trying to simulate the clock divider counting thousands of cycles, yet still provides confirmation that it is working as intended.\n\n\nFigure 8: Test version of clock divider module testbench output.\n\nFigure 8 gives confirmation that the module outputs match the expected values for all tests."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nI found lab 2 significantly easier than lab 1, because I had a gained familiarity with the software and board, and had already assembled my parts. The verilog itself was also very quick, as I was able to reuse my display and divider modules from lab 1. Therefore, I had the verilog and testbenches written in around 2 hours.\nIt took around 2 more hours to assemble my breadboard, and 2 hours debugging some subtle issues. One such issue was that my verilog assumed a active high reset, wheras the board button is active low. That caused the digit to be stuck on one of them and not oscillate back and forth.\nOverall, I worked on this lab for around 12 hours including the writeup and diagrams.\nThe FPGA succesfully controlled both digits on the seven segment display with no noticable flickering, and the 5 led lights that display the sum. The lab was very succesful and I enjoyed working on it.\nI still had issues getting the FPGA programmer to help, but Javier gave me a useful tip which seems to be helping. I might still try out the alternative programmer that has been suggested."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\nPrompt 1: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\n\nI used my ChatGPT free account to create this, and the file is here on my github.\nI opened up the verilog in Radiant, it synthesized without any issues. The first thing I noticed when looking at the Netlist analyzer is that there are 2 sets of seven segment display outputs. I think that the wording of the prompt suggests this, and that if I wanted to run this on my board (which doesn’t have enough GPIO pins to allow 14 pins for the seven segment display) I could easily ask Chat to fix this for me. Essentially, I think that it was correct for what it was trying to do.\nLooking at the SystemVerilog itself, I noticed that while the AI included pleanty inline comments explaining what each line does, the over style was very poor, with no modules. I think that by modifying the prompt to tell it to use a modular design it would do well on this.\nNext I tried the second prompt given in the lab manual.\n\nPrompt 2: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\nFor some reason, despite providing the files as context, the LLM did not use the correct port names when instantiating the modules. For example for the divider it used clk_in and clk_out instead of clk and divided_clk which my module uses. Likewise it used in and out for the seven segment display instead of s and seg. It also got the parameter name TOGGLE_COUNT wrong and called it n. Somehow it new what the inputs, outputs, and parameters were, but somehow did not copy over the names correctly.\nI performed those manual changes, the design synthesized correctly. It got the oscillator correct, and the rest of the SystemVerilog code seems reasonable (but also not modular like Prompt 1 response).\nI think that a lot of these errors would be better with a different model and IDE such as Cursor instead of providing the files to chat gpt. During my internship I found that Cursor + Claude Sonnet worked very well and didn’t make these kinds of mistakes, but I do not have access to these anymore. For things like writting modular code, style, and comments, something like a Cursor rules file, or a thing that you add to every prompt/conversation with specific instructions would help get results that are closer to what the user desires."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "This is the first Lab in E155 working with microcontrollers. The goal of this lab is to get comfortable with our microcontroller, the STM32L432KC, and to learn how to write our own drivers and header files."
  },
  {
    "objectID": "labs/lab4/lab4.html#introduction",
    "href": "labs/lab4/lab4.html#introduction",
    "title": "Lab 4: Digital Audio",
    "section": "",
    "text": "This is the first Lab in E155 working with microcontrollers. The goal of this lab is to get comfortable with our microcontroller, the STM32L432KC, and to learn how to write our own drivers and header files."
  },
  {
    "objectID": "labs/lab4/lab4.html#design-and-testing-methodology",
    "href": "labs/lab4/lab4.html#design-and-testing-methodology",
    "title": "Lab 4: Digital Audio",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThe primary challenges of this lab are in the setup of the microcontroller, getting the clock to function as expected, and setting specific bits in registers to get everything to work. Therefore, a lot of the troubleshooting is to make sure that everything is setup correctly.\nOnce I am able to get the GPIO pins to toggle at specified frequencies, the final testing to confirm correct functionality is relatively simple.\n\nSegger Testing\nBefore ever flashing the MCU or building a circuit, I tested my code in Segger Embedded Studio, loaded with drivers and packages for my STM32L432KC MCU. This allowed me to test that my code was working as intended. I looked into the relevant registers to ensure that bits were getting updated, specfically that the counters were incrementing and resetting and the desired points.\n\n\nOsilloscope Testing\nTo confirm that the song is playing at the correct frequency of notes and the duration is correct, I will use an oscilloscope.\n\n\nEar test\nOf course, for this type of lab the ultimate test is to make sure that the songs, Fur Elise and Happy Birthday, sound to our ears as they expect. Our ears are very good at detecting if the intervals between notes are not correct, or if the rythem is not steady. I don’t have perfect pitch so I cannot confirm that it is in the correct key, but I can tell if everything is correct relative to each other.\n\n\nTimer Configuration\nThe first thing that the main function does is configure flash and the system clock to use the PLL at 80 Mhz. I utilized header files and drivers that were provided as part of this lab.\nconfigureFlash();\nconfigureClock();\nNext, I configured the GPIO to connect my song to an external pin to be able to be played through the speaker.\n// configure GPIO\nRCC-&gt;AHB2ENR |= (1 &lt;&lt; 0); // turn GPIOA clock\nRCC-&gt;APB2ENR |= (1 &lt;&lt; 16); // enable TIM15\nRCC-&gt;APB2ENR |= (1 &lt;&lt; 17); // enable TIM16\nThen I specified for that pin to be pin 6, and set the function to be alternate funcion 14 to connect TIM16 Channel 1.\n// use pin 6\npinMode(6, GPIO_ALT); // set pin 6 to alt function\nGPIO-&gt;AFRL &= ~(0b1111&lt;&lt;4*6); // clear alt func bits\nGPIO-&gt;AFRL |= (14&lt;&lt;4*6); // set pin 6 to alt func 14\nNow, I configure the Timers with the headers and drivers that I wrote:\nconfigureTIM15();\nconfigureTIM16();\nWe can see these functions in the file I wrote, STM32L432KC_TIM.c:\n// Function configureTIM16:\n// Sets up TIM15 for use for measuring duration of a note\n// Uses a prescaler of 700\n// No arguments\nvoid configureTIM15(void) {\n    \n    TIM15-&gt;CR1 &= ~(1&lt;&lt;0); // disable counter\n    TIM15-&gt;PSC = 700; // PSC = 700\n    TIM15-&gt;EGR |= (1&lt;&lt;0); // trigger an update\n    TIM15-&gt;CR1 |= (1&lt;&lt;0); // enable counter\n}\n\n// Function configureTIM16:\n// Sets up TIM16 for use for setting the frequency of a note\n// Uses a prescaler of 6\n// Uses duty cycle of 50%\n// No arguments\nvoid configureTIM16(void){\n\n    // Set PWM mode\n    TIM16-&gt;CCMR1 &= ~(0b111 &lt;&lt; 4);  // clear OC1M[2:0] \n    TIM16-&gt;CCMR1 |= (0b110 &lt;&lt; 4);  // set PWM mode 1\n    TIM16-&gt;CCMR1 |= (1 &lt;&lt; 3);       // Set preload enable\n    TIM16-&gt;CCMR1 &= ~(0b11 &lt;&lt; 0);  // Set CC1 channel as output\n\n    TIM16-&gt;CR1 |= (1 &lt;&lt; 7); // enable ARPE\n    TIM16-&gt;CCER |= (1 &lt;&lt; 0); // Capture/Compare 1 output enable\n    TIM16-&gt;BDTR |= (1 &lt;&lt; 15); // Main output enable\n\n    // set Prescaler\n    TIM16-&gt;PSC = 6; // PSC = 6\n    TIM16-&gt;ARR = 0xFFFF;  // auto-reload\n\n    // Update changes and enable counter \n    TIM16-&gt;CR1 &= ~(1 &lt;&lt; 0); // disable counter\n    TIM16-&gt;EGR |= (1 &lt;&lt; 0); // trigger an update\n    TIM16-&gt;CR1 |= (1 &lt;&lt; 0); // enable counter\n}\nHere we see that the configuration for TIM15 is a lot simpler because it is not connected to a pin and it is not using PWM. For TIM16, we set CCMR1 to PWM mode 1, so that the output flips each cycle when it gets to the value in CCR1 which depends on the duty cycle. Both timers have a prescaler set to match out desired range of frequencies and durations with maximum accuracy.\nNow that the timers are configured, it is just a matter of setting the auto-reload register (ARR) to change the duration or frequency of a note, and updating the timer for the next note. I also update CCR1 to ensure that every note has 50% duty cycle for even volumes.\n// Function setFreq:\n// Sets the frequency (in Hz) on TIM16\n// Arguments: int freq specifies the frequency of a note in Hz\nvoid setFreq(int freq){\n    if (freq == 0){\n        // If freq == 0 it is supposed to be silent\n        TIM16-&gt;CCR1 = 0; // 0 Percent duty cycle \n    } else {\n        // Toggle pin at freq\n        TIM16-&gt;ARR = (80000000/(6+1)/freq) - 1; // 80 MHz / (PSC + 1) / Freq -1 yeields count to produce desired freq\n        TIM16-&gt;CCR1 = ((80000000/(6+1)/freq) - 1)/2; // 50 Percent duty cycle \n        TIM16-&gt;EGR |= (1 &lt;&lt; 0); // trigger an update\n        TIM16-&gt;CR1 |= (1 &lt;&lt; 0); // enable counter\n\n    }\n}\n\n// Function setDur:\n// Sets the delay (in ms) on TIM15\n// Num cycles delay = (ARR+1)*(PSC+1)\n// Arguments: int dur specifies the duration of a note in ms\nvoid setDur(int dur){\n    int cycles_per_ms = 80000000/1000/701; // 80 MHz / (1 s to 1000 ms)/ (Prescaler + 1) \n\n    TIM15-&gt;ARR = cycles_per_ms*dur; // Sets auto-reload register to desired number of ticks\n    TIM15-&gt;EGR |= (1 &lt;&lt; 0); // trigger an update\n    TIM15-&gt;SR &= ~(1 &lt;&lt; 0); // clear UIF bit\n    TIM15-&gt;CNT = 0; // reset counter before while loop\n    \n    while (!(TIM15-&gt;SR & (1&lt;&lt;0))); // waits until counter reaches tick count\n}\n\n\nCalculations\nI need to calculate the frequency of the timers with the specific parameters that I have chosen, particulary the prescaler and the auto-reload register. To do this I will rely on the formula: \\[f_{TIM} = \\frac{f_{input}}{(PSC + 1) * (ARR + 1)}\\]\nFor TIM15 (duration):\n\nARR = duration dependent\nPSC = 700\n\nTo find the min and max durations, I can solve the equaion for when ARR is at its min and max value. When ARR = 0, \\(f_{TIM} = \\frac{f_{input}}{701}\\). With an 80 Mhz clock, that means that the timer will toggle at 114123 Hz, or a minimum delay of 8.7625 \\(\\micro s\\).\nThe max duration is when ARR = h’FFFF = d’65535. \\(f_{TIM} = \\frac{f_{input}}{(700+1)(65535+1)} = 1.7\\) Hz. This gives a max delay of 0.574 s, which is long enough for my longest notes.\nFor TIM16 (PWM):\n\nARR = freq dependent\nPSC = 6\n\nTo find the min and max frequencies, I use the same equation. When ARR = 0, \\(f_{TIM} = \\frac{f_{input}}{6+1}\\). For 80 Mhz, this gives us 11.4 MHz. When ARR = h’FFFF = d’65535, \\(f_{TIM} = \\frac{f_{input}}{(6+1)(65535+1)} = 174.38\\) Hz. We are looking for frequencies between around 200-1400 Hz, so this will cover this range.\nOne part of this lab is ensuring that pitches are correct to 1% accuracy accross 200-1000 Hz.\n\n200 Hz:\n\\[200 = \\frac{80,000,000}{(6+1)(ARR+1)}\\] \\[ARR = \\frac{399993}{7} \\approx 57142\\]\nPlugging back in to see the actual frequency with \\(ARR = 57142\\): \\[f_{TIM} = \\frac{80,000,000}{(6+1)(57142+1)} = 199.9995 Hz\\] Percent error: \\[\\% Error = \\frac{|199.9995-200|}{200} * 100 = 0.00025 \\% &lt; 1 \\% \\] We can see that the error introduced by rouding from the ARR is way less than 1 %.\n\n\n1000 Hz:\n\\[1000 = \\frac{80,000,000}{(6+1)(ARR+1)}\\] \\[ARR = \\frac{79993}{7} \\approx 11428\\]\nPlugging back in to see the actual frequency with \\(ARR = 11428\\): \\[f_{TIM} = \\frac{80,000,000}{(6+1)(11428+1)} = 999.9625 Hz\\] Percent error: \\[\\% Error = \\frac{|999.9625-1000|}{1000} * 100 = 0.00375 \\% &lt; 1 \\% \\] We can see that the error introduced by rouding from the ARR is way less than 1 %.\n\n\n\nChoosing Auto-Reload Register Values\nTo choose an ARR value to match the duration or frequency, I use the same formula as before: \\[f_{TIM} = \\frac{f_{input}}{(PSC + 1) * (ARR + 1)}\\]\nNow that we know the prescaler values, given a known desired frequency or duration we can solve for ARR.\nFor duration, I first solve for the number of ticks in a ms with my PLL frequency and prescaler, then multiply that the number of ms that I want.\nint cycles_per_ms = 80000000/1000/701; // 80 MHz / (1 s to 1000 ms)/ (Prescaler + 1) \n\nTIM15-&gt;ARR = cycles_per_ms*dur; // Sets auto reload register to desired number of ticks\nFor frequency, I simply solve for ARR and plug in values. CCR1 is set to half of ARR for 50% duty cycle.\nTIM16-&gt;ARR = (80000000/(6+1)/freq) - 1; // 80 MHz / (PSC + 1) / Freq -1 yeields count to produce desiredd freq\nTIM16-&gt;CCR1 = ((80000000/(6+1)/freq) - 1)/2; // 50 Percent duty cycle"
  },
  {
    "objectID": "labs/lab4/lab4.html#technical-documentation",
    "href": "labs/lab4/lab4.html#technical-documentation",
    "title": "Lab 4: Digital Audio",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe code for my project can be found on my github page. Lab4 Github Repository\n\nSchematic\n\n\nFigure 1: Schematic of the Physical Circuit.\n\nFigure 1 shows the physical layout of the design. It shows the microcontroller Pin 6, which has the audio output, first going through a 50 k\\(\\Omega\\) potentiometer to be able to adjust the volume. Then this output goes into the LM386 audio amplifier. By connecting 5V to pin 6, ground to pin 2, and the input to pin 3, and not connection any other pins, we get a gain of 20. This allows us to get a higher voltage output then would have been possible then straight out of the MCU.\nFinally, the amplifier output goes to a 8 W, 4 \\(\\Omega\\) speaker."
  },
  {
    "objectID": "labs/lab4/lab4.html#results-and-discussion",
    "href": "labs/lab4/lab4.html#results-and-discussion",
    "title": "Lab 4: Digital Audio",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI accomplished all of the perscribed tasks: The speaker plays the songs with notes at the correct frequency and duration.\nOsilloscope Waveforms:\n\nDuration\nTo confirm that the duration of each note is right, I performed tests by looking at the oscilloscope trace for a note of known duration.\n\n\nFigure 2: Oscilloscope trace of a 200 ms duration note.\n\nPercent error: \\[\\% Error = \\frac{|200-200|}{200} * 100 = 0 \\% &lt; 1 \\% \\]\n\n\nFigure 3: Oscilloscope trace of a 500 ms duration note.\n\nPercent error: \\[\\% Error = \\frac{|500-500|}{500} * 100 = 0 \\% &lt; 1 \\% \\]\n\n\nFrequency\nTo find frequency from the oscilloscope trace, we use the formula \\(f = \\frac{1}{T}\\).\n\n\nFigure 4: Oscilloscope trace of a 200 Hz note.\n\nPercent error: \\[\\% Error = \\frac{|198.8-200|}{200} * 100 = 0.596 \\% &lt; 1 \\% \\]\n\n\nFigure 5: Oscilloscope trace of a 220 Hz note.\n\nPercent error: \\[\\% Error = \\frac{|218.8-220|}{220} * 100 = 0.59 \\% &lt; 1 \\% \\]\n\n\nFigure 6: Oscilloscope trace of a 800 Hz note.\n\nPercent error: \\[\\% Error = \\frac{|798.7-800|}{800} * 100 = 0.160 \\% &lt; 1 \\% \\]\n\n\nFigure 7: Oscilloscope trace of a 1000 Hz note.\n\nPercent error: \\[\\% Error = \\frac{|996.0-1000|}{1000} * 100 = 0.398 \\% &lt; 1 \\% \\]\nFrom this we can see that frequencies accross the range of 200 Hz to 1000 Hz all have less than 1% error."
  },
  {
    "objectID": "labs/lab4/lab4.html#conclusion",
    "href": "labs/lab4/lab4.html#conclusion",
    "title": "Lab 4: Digital Audio",
    "section": "Conclusion",
    "text": "Conclusion\nLab 4 was quite difficult, due to it being the first MCU lab. I spent around 20 hours in total working on this lab, with a lot of time just looking through the datasheets.\nThe lab was succesfull as I was able to get everything to work as intended.\nThe most difficult part of this lab was going through the datasheet to figure out which registers and bits needed to be set. It was easy to go through the mechanics of clearing and setting bits when I knew what my goal was, but it was very difficult to figure out how to use the timers."
  },
  {
    "objectID": "labs/lab4/lab4.html#ai-prototype-summary",
    "href": "labs/lab4/lab4.html#ai-prototype-summary",
    "title": "Lab 4: Digital Audio",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\nLLM Prompt:\nWhat timers should I use on the STM32L432KC to generate frequencies ranging from 220Hz to 1kHz? What’s the best choice of timer if I want to easily connect it to a GPIO pin? What formulae are relevant, and what registers need to be set to configure them properly?\n\nI was very impressed by ChatGPT’s output even without providing the datasheet. The first section of the response was non the different timers that I could use, and it gave a very helpful description of the different timers, explaining which ones were easily connected to GPIO pins, which were 16 and 32 bits, and more. It reflected the datasheet to the best of my knowledge, for example recomending TIM15 and TIM16 which we looked at in class.\nFor the fommulas, it was also very helpful. It explained the prescaler (PSC) and the auto-reload register (ARR), and gave the following function for the timer update frequency as a function of these two parameters: \\[ f_{update} = \\frac{f_{TIMxCLK}}{(PSC+1)(ARR+1)} \\]\nIt additionally gave some other formulas for different modes, such as toggle on compare. It gave example calculations that solved for the pin frequency with different parameters.\nTo configure the registers, it gave the following output:\n\nEnable clock timer:\n\nRCC_APB1ENR1 → set TIM2EN.\n\nSet prescaler & ARR:\n\nTIM2-&gt;PSC = 799;      // prescaler TIM2-&gt;ARR = 226;      // auto-reload\n\nConfigure Output Compare\n\nTIM2-&gt;CCMR1 |= (0b011 &lt;&lt; TIM_CCMR1_OC1M_Pos);  // OC1M = toggle on match TIM2-&gt;CCER  |= TIM_CCER_CC1E;                  // Enable channel TIM2-&gt;CCR1   = 0;                              // Compare value\n\nMap channel to GPIO pin (Alternate Function)\n\nEnable GPIO clock. Set MODER to alternate function. Configure AFR (look up AF mapping in datasheet: e.g. PA0 → TIM2_CH1 AF1).\n\nEnable counter\n\nTIM2-&gt;CR1 |= TIM_CR1_CEN;\nSummary:\n\nBest timers:\n\nTIM1 (advanced, good defaults)\n\nTIM2 (32-bit, flexible)\n\nTIM15–TIM17 (also fine)\n\nAvoid TIM6/7 (no GPIO output)\n\nFormulas:\n\nUpdate frequency:\nf_update = f_clk / ((PSC + 1) * (ARR + 1))\nToggle frequency:\nf_toggle = f_update / 2\n\nRegisters needed:\n\nPSC, ARR, CCRn\nCCMRx (mode: toggle / PWM)\nCCER (enable output)\nCR1 (enable timer)\nGPIOx_MODER, GPIOx_AFR (pin mapping)\n\n\nOverall, this gave a very good overview of the general steps that are necessary to configure the clock, yet it was missing specific infomration, such as the registers and bits that need to be set. I am confident that by giving the datasheet, an example header file, and more specific instructions for what I wanted I could get the header file that I am trying to make."
  },
  {
    "objectID": "posts/lab_4_reflection.html",
    "href": "posts/lab_4_reflection.html",
    "title": "Lab 4 Reflection",
    "section": "",
    "text": "I just finished the first MCU lab of E155, and it was difficult because we had to write header files and drivers for our specific MCU by looking at the data sheet. I am pretty comfortable writting in C, but it was difficult to use the built in timers becuase there were many specific registers that had to be set. Once I knew that a register had to be set to a specific mode, the syntax of setting it was very simple, but I tested my design numerous times without it working because a register was not properly setup."
  },
  {
    "objectID": "posts/labs_1-3_reflection.html",
    "href": "posts/labs_1-3_reflection.html",
    "title": "Labs 1-3 Reflections",
    "section": "",
    "text": "I just finished lab 3 in E155, finishing up the section focusing on FPGAs. Over labs 1-3 I worked on projects centered around seven segment displays, each using the learnings from the previous labs. In lab 1, I configured 4 dip switches to control a hexadecimal digit on a seven segment display.\nThe following week in lab 2, I resused many of the same modules from lab 1 to have 2 separate dip switches to represent two numbers simultaneously on 2 different seven segment displays. The challenge here was utilizing clock multiplexing and PNP transistors to rapidly switch between powering one display and the other, giving the illusion that both are on simultaneously. In reality, only one is ever on a time, but it is way to fast for the human eye to detect any flickering. This allows us to not duplicate the number of pins and hardware that we use do add another display.\nLab 3 built on lab 2 even further, by using a 4x4 keypad to allow a user to click on a number, and the keypad shows the 2 most recently pressed numbers. This introduced a number of challenges, such as dealing with clock debouncing, dealing with multiple keypresses at once, pressing a key multiple times in a row, and dealing with asynchronous inputs, to name a few.\nThroughout these projects, I got significantly better at utilizing version control, testbenches, and creating block diagrams and schematics of my designs. It has been exciting to present my projects in a more official format on my quarto portfolio, even if it means extra work during the week. So far, I have been pretty good with time managament, with no late nights and having used no late passes or redos. I need to try to keep this up for the MCU labs, but I am less familiar with this content so it will likely be more difficult."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "I am Eoin O’Connell, a junior engineering student at Harvey Mudd College. I participate on the CMS Cross Country and Track and Field teams. This is my portfolio for E155, Microprocessor Systems: Design & Application."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Here is the class webpage with infomration about the class, labs, and project: Course Webpage"
  },
  {
    "objectID": "E155-Project/IIR_filter.html",
    "href": "E155-Project/IIR_filter.html",
    "title": "IIR Filter Math and Calculations",
    "section": "",
    "text": "An IIR (Infinite Impulse Response) filter is a digital filter that computes each output sample using both current and past input values as well as past output values. This feedback structure allows it to achieve sharp frequency responses with fewer coefficients than an FIR filter but can introduce stability and phase concerns.\n\n\n\\[\ny[n] = \\sum_{k=0}^{M} b_k\\,x[n-k] - \\sum_{k=1}^{N} a_k\\,y[n-k]\n\\]\n\n\n\n\\[\ny[n] = b_0\\,x[n] + b_1\\,x[n-1] + b_2\\,x[n-2]\n      - a_1\\,y[n-1] - a_2\\,y[n-2]\n\\]\n\n\n\nThe most intuitive way to visualize an IIR filter is in Direct Form I. In this form, you can clearly see input samples being delayed (ie. \\(x[n-1]\\), \\(x[n-2]\\)), and being multiplied by a coefficient \\(a_k\\) and summed together. Likewise, output \\(y[n]\\) gets delayed (ie. \\(y[n-1]\\), \\(y[n-2]\\)), and scaled by \\(b_k\\) and summed together to find the current \\(y[n]\\).\n\n\nFigure 1: IIR Filter Direct Form I.\n\nWe can recognize that there are two independent linear systems on either side of the dashed line. A property of linear systems is that we can rearrange them. This leads us to the following intermediate form.\n\n\nFigure 2: IIR Filter Direct Intermediate Form.\n\nLooking at figure 2, the delay elements are in parallel with nothing in between them. This means that they are always the same values throughout the delay chain. We can reduce this redundancy by combining both sides to use the same delay elements.\n\n\nFigure 3: IIR Filter Direct Form II.\n\nFigure 3 shows how the delay elements are combined to create the most compact implementation, known as Direct Form II. This structure is also the most memory-efficient, requiring only two stored values instead of four as in Direct Form I. Therefore, this is the form used for the IIR algorithm implemented on the FPGA."
  },
  {
    "objectID": "E155-Project/IIR_filter.html#iir-filter-overview",
    "href": "E155-Project/IIR_filter.html#iir-filter-overview",
    "title": "IIR Filter Math and Calculations",
    "section": "",
    "text": "An IIR (Infinite Impulse Response) filter is a digital filter that computes each output sample using both current and past input values as well as past output values. This feedback structure allows it to achieve sharp frequency responses with fewer coefficients than an FIR filter but can introduce stability and phase concerns.\n\n\n\\[\ny[n] = \\sum_{k=0}^{M} b_k\\,x[n-k] - \\sum_{k=1}^{N} a_k\\,y[n-k]\n\\]\n\n\n\n\\[\ny[n] = b_0\\,x[n] + b_1\\,x[n-1] + b_2\\,x[n-2]\n      - a_1\\,y[n-1] - a_2\\,y[n-2]\n\\]\n\n\n\nThe most intuitive way to visualize an IIR filter is in Direct Form I. In this form, you can clearly see input samples being delayed (ie. \\(x[n-1]\\), \\(x[n-2]\\)), and being multiplied by a coefficient \\(a_k\\) and summed together. Likewise, output \\(y[n]\\) gets delayed (ie. \\(y[n-1]\\), \\(y[n-2]\\)), and scaled by \\(b_k\\) and summed together to find the current \\(y[n]\\).\n\n\nFigure 1: IIR Filter Direct Form I.\n\nWe can recognize that there are two independent linear systems on either side of the dashed line. A property of linear systems is that we can rearrange them. This leads us to the following intermediate form.\n\n\nFigure 2: IIR Filter Direct Intermediate Form.\n\nLooking at figure 2, the delay elements are in parallel with nothing in between them. This means that they are always the same values throughout the delay chain. We can reduce this redundancy by combining both sides to use the same delay elements.\n\n\nFigure 3: IIR Filter Direct Form II.\n\nFigure 3 shows how the delay elements are combined to create the most compact implementation, known as Direct Form II. This structure is also the most memory-efficient, requiring only two stored values instead of four as in Direct Form I. Therefore, this is the form used for the IIR algorithm implemented on the FPGA."
  },
  {
    "objectID": "E155-Project/IIR_filter.html#coefficient-calculations",
    "href": "E155-Project/IIR_filter.html#coefficient-calculations",
    "title": "IIR Filter Math and Calculations",
    "section": "Coefficient Calculations",
    "text": "Coefficient Calculations\nNow that we understand the structure of the filter, we still need to calculate the \\(a_k\\) and \\(b_k\\) coefficients for our filters. Our 3-band EQ will consist of 3 cascading filters, one each for lows, mids, and highs. Each of these filters will consist of a second-order order IIR filter. Thus, the coefficients for each filter will be independent, being a fucntion of the potentiometer input of the corresponding band.\nOur 3-band EQ uses three common second-order filter types. Each type has its own way of calculating the biquad coefficients \\(a_k\\) and \\(b_k\\).\n\nLow Shelf Filter\nA low shelf boosts or attenuates frequencies below a certain cutoff frequency (\\(f_c\\)). The coefficients are calculated from the desired cutoff, gain, and sampling rate:\n\\[\n\\begin{aligned}\n\\omega &= 2 \\pi \\frac{f_c}{f_s} \\\\\nA &= 10^{\\text{gain}/40} \\\\\n\\alpha &= \\frac{\\sin(\\omega)}{2} \\sqrt{\\frac{A+1}{A-1}} \\\\\nb_0, b_1, b_2, a_0, a_1, a_2 &= \\text{functions of } \\omega, \\alpha, A\n\\end{aligned}\n\\]\n\n\nHigh Shelf Filter\nA high shelf affects frequencies above a certain cutoff (\\(f_c\\)), either boosting or cutting them. The coefficient calculation is similar to the low shelf but reflects the change in frequency range:\n\\[\n\\begin{aligned}\n\\omega &= 2 \\pi \\frac{f_c}{f_s} \\\\\nA &= 10^{\\text{gain}/40} \\\\\n\\alpha &= \\frac{\\sin(\\omega)}{2} \\sqrt{\\frac{A+1}{A-1}} \\\\\nb_0, b_1, b_2, a_0, a_1, a_2 &= \\text{functions of } \\omega, \\alpha, A\n\\end{aligned}\n\\]\n\n\nPeaking (Mid Cut / Boost) Filter\nA peaking filter boosts or cuts a band of frequencies around a center frequency (\\(f_c\\)), defined by a Q-factor that sets the bandwidth:\n\\[\n\\begin{aligned}\n\\omega &= 2 \\pi \\frac{f_c}{f_s} \\\\\n\\alpha &= \\frac{\\sin(\\omega)}{2 Q} \\\\\nA &= 10^{\\text{gain}/40} \\\\\nb_0, b_1, b_2, a_0, a_1, a_2 &= \\text{functions of } \\omega, \\alpha, A\n\\end{aligned}\n\\]\nEach of these formulas is then normalized by (\\(a_0\\)) to produce the final biquad coefficients (\\(b_0, b_1, b_2, a_1, a_2\\)) used in the FPGA implementation. The potentiometer for each band maps directly to the filter parameters (cutoff, gain, or Q), allowing real-time control."
  },
  {
    "objectID": "E155-Project/IIR_filter.html#stability-considerations",
    "href": "E155-Project/IIR_filter.html#stability-considerations",
    "title": "IIR Filter Math and Calculations",
    "section": "Stability Considerations",
    "text": "Stability Considerations\nIIR filters rely on feedback from past outputs, which means their stability must be carefully managed. For our 3-band EQ, stability is particularly important when using high gains or narrow Q-factors in the peaking (mid) filter, or extreme boost/cut in the low and high shelf filters.\nA filter becomes unstable if the poles of its transfer function lie outside the unit circle in the z-plane. Practically, this can happen when: - Gain values are too large\n- Q-factor is too high (causing a very narrow band with high resonance)\n- Coefficient quantization on the FPGA introduces rounding errors\nTo ensure stable operation in our FPGA implementation, we: 1. Limit the maximum gain and Q values based on typical audio ranges.\n2. Use Direct Form II to minimize memory usage but carefully handle scaling to avoid overflow.\n3. Normalize all coefficients by (\\(a_0\\)) and use sufficient fixed-point precision for the coefficient representation.\nBy following these precautions, each band of the EQ remains stable across the full range of potentiometer settings, ensuring smooth and reliable real-time audio filtering."
  },
  {
    "objectID": "E155-Project/project_proposal.html",
    "href": "E155-Project/project_proposal.html",
    "title": "Project Proposal: Real Time 3-Band EQ Filtering",
    "section": "",
    "text": "We will create a real-time 3-band equalizer (EQ) that can independently remove or boost lows, mids, and highs in an incoming audio signal. The system will feature three control knobs, one for each frequency range.\nThe project will accept audio through a standard 1/8-inch (3.5 mm) auxiliary input, allowing playback from a computer or mobile device. The analog audio signal will be digitized by an ADC, processed in real time by an FPGA using digital filtering, and then converted back to analog via a DAC for playback through a pair of speakers (left and right).\nThe design is going to be developed and implemented on an STM32L432KC Microcontroller, and an iCE40 UltraPlus FPGA.\n\n\n\n\n\nInput / Output:\nAudio is input via a 1/8-inch aux cable and output through a speaker in the digital lab.\nBypass Behavior:\nWhen all EQ knobs are in their default (neutral) positions, the output should closely match the original input audio.\nFrequency Bands:\nThe equalizer will feature three independently adjustable bands:\n\nLow band: ~100 Hz – 400 Hz\n\nMid band: ~400 Hz – 2 kHz\n\nHigh band: ~2 kHz – 8 kHz\n\nControl Interface:\nEach band will have its own potentiometer for analog gain adjustment (boost/cut).\nLatency:\nThe system will maintain real-time operation with &lt; 50 ms latency, ensuring audio remains synchronized with video sources such as YouTube.\nFiltering Performance:\nEach EQ band must correctly boost or attenuate its designated frequency range without introducing distortion or unintended interaction between bands. The correctness of filtering behavior will be verified through both frequency response measurements and subjective listening (ear tests).\nVerification:\nThe final report will include theoretical frequency responses for each band and confirm them via hardware measurements.\n\n\n\n\n\n\n\n\nPerform real-time IIR-based filtering for the three EQ bands.\nHandle I²S communication with both ADC and DAC devices.\nGenerate appropriate clock signals using internal oscillators (HSOSC or LFOSC).\n\n\n\n\n\nRead three analog potentiometer inputs (one per frequency band).\nCompute IIR filter coefficients based on knob positions.\nTransmit updated coefficients to the FPGA via SPI.\n\n\n\n\n\n\nConvert analog data to digital data\nCommunicate over I2S protocol\n\n\n\n\n\nConvert digital data to analog data\nCommunicate over I2S protocol\n\n\n\n\n\nEnd-to-end latency (ADC → FPGA processing → DAC) or buffering delays cause audible lag, clicking, or make the system unusable for live monitoring.\nMaking the ADC, DAC, MCU and FPGA clocks not synchronized\nIncreased quantization noise from using 16-bit data paths\nHigh-frequency content aliasing into the audio band if the ADC sample rate or analog filter are insufficient.\nIncorrect wiring between components\nOutput clipping at high volume damaging speakers or hearing.\nExceeding FPGA LUT’s, and more importantly, DSP slices\n\nOur FPGA Contains only 8 16x16 DSP slices, requiring clever pipelining and multiplexing to filter all signals in time\n\n\n\n\n\n\n\n\n\nComponent\nQuantity\nFunction\nInterface\nApprox. Cost\nNotes\n\n\n\n\nAdafruit PCM5102 I²S DAC\n1\nDigital-to-Analog Converter\nI²S\n~$6\n16–32 bit, 8–384 kHz sampling, 3.3V logic, 2.1 V-rms output\n\n\nPCM1808 ADC\n1\nAnalog-to-Digital Converter\nI²S\n~$6\n24-bit, 8–96 kHz sampling, 3.3–5V supply\n\n\nSTX-3000 Audio Jack\n1\nStereo audio input connector\nAnalog\n~$1\n3.5 mm TRS jack, through-hole and breadboard compatible\n\n\n3362 1/4-inch Square Trimpot Potentiometers\n3\nUser control for low, mid, and high bands\nAnalog\nStockroom\nReads by MCU ADC pins\n\n\nICE40 UltraPlus FPGA Board\n1\nReal-time DSP core\nI²C, SPI\nOn Hand\nPerforms all filtering\n\n\nSTM32L432KC MCU Board\n1\nUser interface and coefficient computation\nSPI, ADC\nOn Hand\nCommunicates with FPGA\n\n\nMiscellaneous Components\nn/a\nOp-amps, resistors, capacitors, wires\nAnalog\nStockroom\nUsed for signal conditioning, biasing, and connections\n\n\n\nSubtotal parts cost: ~$13 (excluding lab stock components).\nShipping and Taxes: ~$8\nTotal external parts cost: ~$21.\n\n\n\n\n\n\nFigure 1: Flow Chart of Partitioning and Connections.\n\n\n\n\nThe key performance characteristics of our EQ filter are defined by the sampling rate, ADC/DAC bit rate, and FPGA processing speed.\nSampling Rate / Nyquist:\nBy the Shannon–Nyquist theorem, the sampling frequency must exceed twice the highest signal frequency. Since the human ear can hear to around ~20 kHz, \\(f_s &gt; 40\\,\\text{kHz}\\).\nWe will use 48 kHz, providing a 24 kHz Nyquist limit and headroom for filtering.\nBit Rate:\nAt 48 kHz, 24 bits/sample, and stereo audio:\n\\[\nR = f_s \\times B \\times C = 48{,}000 \\times 24 \\times 2 \\approx 2.3\\,\\text{Mbps}\n\\]\nWith 32-bit I²S frames, the bit clock is approximately 3 MHz, easily handled by the FPGA.\nFPGA Throughput and Latency:\nAssuming a 48 kHz sample rate (sample period ≈ 20.83 µs), a 50 MHz fabric clock gives\n\\[\n\\frac{50\\ \\text{MHz}}{48\\ \\text{kHz}} \\approx 1042\n\\]\ncycles per sample, which is more than sufficient for three IIR filters using time-multiplexed multiplies. If the ADC and DAC run from the same sample clock and we complete filtering within one sample period, the per-sample processing latency is about 20.8 µs (\\(\\frac{1}{f_{ADC/DAC}}\\)). The ADC/DAC and any pipelining typically add only a few samples of delay (on the order of tens of microseconds). Even with conservative buffering, end-to-end latency remains ≪ 50 ms, easily meeting our real-time requirement.\nResolution / Noise:\n24-bit audio provides ~146 dB theoretical SNR; internal 32-bit accumulation will preserve precision and avoid quantization noise.\nOverall, the design easily meets real-time performance needs: 48 kHz sample rate, &lt;1 ms latency, and sufficient precision for transparent audio quality.\nLUT Usage\nBecause the filtering is duplicated, we duplicate the filtering hardware. The 3-band EQ consists of 3 cascading filters (low, mid, high), with each band using biquads. That means that we do \\(3 x 5 = 15\\) multiplies per sample. These are 16 bit multiples, and the FPGA has 8 16x16 DSP slices. That means that as long as we run the FPGA at least 1.875 times the sampling frequency of the ADC/DAC then we can fit in all the multiplies. For a sampling rate of 48 KHz, this will be easy as the FGPA can run on order of MHz.\n\n\n\nThe table below outlines the major project milestones, their target completion dates, and the team member responsible for leading each task. Tasks are ordered chronologically to ensure smooth integration of the hardware and firmware components leading up to a functional prototype.\n\n\n\nTask\nGoal Date\nLead Member\n\n\n\n\nOrder parts (after project approval)\nAs soon as approved\nDrake\n\n\nSuccessfully throughput unfiltered audio\n11/10\nDrake\n\n\nSuccessfully demo filtering in MATLAB\n11/10\nEoin\n\n\nSuccessfully measure potentiometer input on MCU\n11/17\nDrake\n\n\nFinish RTL design and verification via test benches\n11/17\nEoin\n\n\nComplete and test working prototype\n11/24\nWhole Team\n\n\n\nTask Division:\nDrake will primarily focus on the hardware integration side of the project, including part procurement, audio signal interfacing, and MCU testing. Eoin will lead the digital signal processing implementation, including MATLAB filter validation and FPGA RTL design with test benches. Both team members will collaborate closely in the final integration and prototype testing phase to ensure seamless hardware–software coordination and successful real-time operation.\nAs the project progresses, we will monitor our progress and reallocate tasks as needed to ensure balanced workloads and timely completion. Work will be tracked through a shared action-items spreadsheet. Additionally, we both aim to maintain a complete understanding of the entire system, ensuring that each of us can independently explain and reproduce every part of the project."
  },
  {
    "objectID": "E155-Project/project_proposal.html#project-proposal",
    "href": "E155-Project/project_proposal.html#project-proposal",
    "title": "Project Proposal: Real Time 3-Band EQ Filtering",
    "section": "",
    "text": "We will create a real-time 3-band equalizer (EQ) that can independently remove or boost lows, mids, and highs in an incoming audio signal. The system will feature three control knobs, one for each frequency range.\nThe project will accept audio through a standard 1/8-inch (3.5 mm) auxiliary input, allowing playback from a computer or mobile device. The analog audio signal will be digitized by an ADC, processed in real time by an FPGA using digital filtering, and then converted back to analog via a DAC for playback through a pair of speakers (left and right).\nThe design is going to be developed and implemented on an STM32L432KC Microcontroller, and an iCE40 UltraPlus FPGA.\n\n\n\n\n\nInput / Output:\nAudio is input via a 1/8-inch aux cable and output through a speaker in the digital lab.\nBypass Behavior:\nWhen all EQ knobs are in their default (neutral) positions, the output should closely match the original input audio.\nFrequency Bands:\nThe equalizer will feature three independently adjustable bands:\n\nLow band: ~100 Hz – 400 Hz\n\nMid band: ~400 Hz – 2 kHz\n\nHigh band: ~2 kHz – 8 kHz\n\nControl Interface:\nEach band will have its own potentiometer for analog gain adjustment (boost/cut).\nLatency:\nThe system will maintain real-time operation with &lt; 50 ms latency, ensuring audio remains synchronized with video sources such as YouTube.\nFiltering Performance:\nEach EQ band must correctly boost or attenuate its designated frequency range without introducing distortion or unintended interaction between bands. The correctness of filtering behavior will be verified through both frequency response measurements and subjective listening (ear tests).\nVerification:\nThe final report will include theoretical frequency responses for each band and confirm them via hardware measurements.\n\n\n\n\n\n\n\n\nPerform real-time IIR-based filtering for the three EQ bands.\nHandle I²S communication with both ADC and DAC devices.\nGenerate appropriate clock signals using internal oscillators (HSOSC or LFOSC).\n\n\n\n\n\nRead three analog potentiometer inputs (one per frequency band).\nCompute IIR filter coefficients based on knob positions.\nTransmit updated coefficients to the FPGA via SPI.\n\n\n\n\n\n\nConvert analog data to digital data\nCommunicate over I2S protocol\n\n\n\n\n\nConvert digital data to analog data\nCommunicate over I2S protocol\n\n\n\n\n\nEnd-to-end latency (ADC → FPGA processing → DAC) or buffering delays cause audible lag, clicking, or make the system unusable for live monitoring.\nMaking the ADC, DAC, MCU and FPGA clocks not synchronized\nIncreased quantization noise from using 16-bit data paths\nHigh-frequency content aliasing into the audio band if the ADC sample rate or analog filter are insufficient.\nIncorrect wiring between components\nOutput clipping at high volume damaging speakers or hearing.\nExceeding FPGA LUT’s, and more importantly, DSP slices\n\nOur FPGA Contains only 8 16x16 DSP slices, requiring clever pipelining and multiplexing to filter all signals in time\n\n\n\n\n\n\n\n\n\nComponent\nQuantity\nFunction\nInterface\nApprox. Cost\nNotes\n\n\n\n\nAdafruit PCM5102 I²S DAC\n1\nDigital-to-Analog Converter\nI²S\n~$6\n16–32 bit, 8–384 kHz sampling, 3.3V logic, 2.1 V-rms output\n\n\nPCM1808 ADC\n1\nAnalog-to-Digital Converter\nI²S\n~$6\n24-bit, 8–96 kHz sampling, 3.3–5V supply\n\n\nSTX-3000 Audio Jack\n1\nStereo audio input connector\nAnalog\n~$1\n3.5 mm TRS jack, through-hole and breadboard compatible\n\n\n3362 1/4-inch Square Trimpot Potentiometers\n3\nUser control for low, mid, and high bands\nAnalog\nStockroom\nReads by MCU ADC pins\n\n\nICE40 UltraPlus FPGA Board\n1\nReal-time DSP core\nI²C, SPI\nOn Hand\nPerforms all filtering\n\n\nSTM32L432KC MCU Board\n1\nUser interface and coefficient computation\nSPI, ADC\nOn Hand\nCommunicates with FPGA\n\n\nMiscellaneous Components\nn/a\nOp-amps, resistors, capacitors, wires\nAnalog\nStockroom\nUsed for signal conditioning, biasing, and connections\n\n\n\nSubtotal parts cost: ~$13 (excluding lab stock components).\nShipping and Taxes: ~$8\nTotal external parts cost: ~$21.\n\n\n\n\n\n\nFigure 1: Flow Chart of Partitioning and Connections.\n\n\n\n\nThe key performance characteristics of our EQ filter are defined by the sampling rate, ADC/DAC bit rate, and FPGA processing speed.\nSampling Rate / Nyquist:\nBy the Shannon–Nyquist theorem, the sampling frequency must exceed twice the highest signal frequency. Since the human ear can hear to around ~20 kHz, \\(f_s &gt; 40\\,\\text{kHz}\\).\nWe will use 48 kHz, providing a 24 kHz Nyquist limit and headroom for filtering.\nBit Rate:\nAt 48 kHz, 24 bits/sample, and stereo audio:\n\\[\nR = f_s \\times B \\times C = 48{,}000 \\times 24 \\times 2 \\approx 2.3\\,\\text{Mbps}\n\\]\nWith 32-bit I²S frames, the bit clock is approximately 3 MHz, easily handled by the FPGA.\nFPGA Throughput and Latency:\nAssuming a 48 kHz sample rate (sample period ≈ 20.83 µs), a 50 MHz fabric clock gives\n\\[\n\\frac{50\\ \\text{MHz}}{48\\ \\text{kHz}} \\approx 1042\n\\]\ncycles per sample, which is more than sufficient for three IIR filters using time-multiplexed multiplies. If the ADC and DAC run from the same sample clock and we complete filtering within one sample period, the per-sample processing latency is about 20.8 µs (\\(\\frac{1}{f_{ADC/DAC}}\\)). The ADC/DAC and any pipelining typically add only a few samples of delay (on the order of tens of microseconds). Even with conservative buffering, end-to-end latency remains ≪ 50 ms, easily meeting our real-time requirement.\nResolution / Noise:\n24-bit audio provides ~146 dB theoretical SNR; internal 32-bit accumulation will preserve precision and avoid quantization noise.\nOverall, the design easily meets real-time performance needs: 48 kHz sample rate, &lt;1 ms latency, and sufficient precision for transparent audio quality.\nLUT Usage\nBecause the filtering is duplicated, we duplicate the filtering hardware. The 3-band EQ consists of 3 cascading filters (low, mid, high), with each band using biquads. That means that we do \\(3 x 5 = 15\\) multiplies per sample. These are 16 bit multiples, and the FPGA has 8 16x16 DSP slices. That means that as long as we run the FPGA at least 1.875 times the sampling frequency of the ADC/DAC then we can fit in all the multiplies. For a sampling rate of 48 KHz, this will be easy as the FGPA can run on order of MHz.\n\n\n\nThe table below outlines the major project milestones, their target completion dates, and the team member responsible for leading each task. Tasks are ordered chronologically to ensure smooth integration of the hardware and firmware components leading up to a functional prototype.\n\n\n\nTask\nGoal Date\nLead Member\n\n\n\n\nOrder parts (after project approval)\nAs soon as approved\nDrake\n\n\nSuccessfully throughput unfiltered audio\n11/10\nDrake\n\n\nSuccessfully demo filtering in MATLAB\n11/10\nEoin\n\n\nSuccessfully measure potentiometer input on MCU\n11/17\nDrake\n\n\nFinish RTL design and verification via test benches\n11/17\nEoin\n\n\nComplete and test working prototype\n11/24\nWhole Team\n\n\n\nTask Division:\nDrake will primarily focus on the hardware integration side of the project, including part procurement, audio signal interfacing, and MCU testing. Eoin will lead the digital signal processing implementation, including MATLAB filter validation and FPGA RTL design with test benches. Both team members will collaborate closely in the final integration and prototype testing phase to ensure seamless hardware–software coordination and successful real-time operation.\nAs the project progresses, we will monitor our progress and reallocate tasks as needed to ensure balanced workloads and timely completion. Work will be tracked through a shared action-items spreadsheet. Additionally, we both aim to maintain a complete understanding of the entire system, ensuring that each of us can independently explain and reproduce every part of the project."
  }
]