<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Drake Gonzales &amp; Eoin O’Connell">

<title>Project: Real Time Stereo 3-Band EQ Filtering – E155 Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">E155 Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../labs.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../E155-Project/project.html" aria-current="page"> 
<span class="menu-text">Project</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#project-proposal" id="toc-project-proposal" class="nav-link active" data-scroll-target="#project-proposal">Project Proposal</a>
  <ul class="collapse">
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#functional-specifications" id="toc-functional-specifications" class="nav-link" data-scroll-target="#functional-specifications">Functional Specifications</a></li>
  <li><a href="#system-partitioning" id="toc-system-partitioning" class="nav-link" data-scroll-target="#system-partitioning">System Partitioning</a></li>
  <li><a href="#analog-to-digital-converter-adc-responsibilities" id="toc-analog-to-digital-converter-adc-responsibilities" class="nav-link" data-scroll-target="#analog-to-digital-converter-adc-responsibilities"><strong>Analog to Digital Converter (ADC) Responsibilities</strong></a></li>
  <li><a href="#digital-to-analog-converter-dac-responsibilities" id="toc-digital-to-analog-converter-dac-responsibilities" class="nav-link" data-scroll-target="#digital-to-analog-converter-dac-responsibilities"><strong>Digital to Analog Converter (DAC) Responsibilities</strong></a></li>
  <li><a href="#risks-for-project" id="toc-risks-for-project" class="nav-link" data-scroll-target="#risks-for-project"><strong>Risks for project</strong></a></li>
  <li><a href="#hardware-components" id="toc-hardware-components" class="nav-link" data-scroll-target="#hardware-components">Hardware Components</a></li>
  <li><a href="#block-diagram" id="toc-block-diagram" class="nav-link" data-scroll-target="#block-diagram">Block Diagram</a></li>
  <li><a href="#performance-calculations" id="toc-performance-calculations" class="nav-link" data-scroll-target="#performance-calculations">Performance Calculations</a></li>
  <li><a href="#project-timeline-and-task-division" id="toc-project-timeline-and-task-division" class="nav-link" data-scroll-target="#project-timeline-and-task-division">Project Timeline and Task Division</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Project: Real Time Stereo 3-Band EQ Filtering</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Drake Gonzales &amp; Eoin O’Connell </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="project-proposal" class="level2">
<h2 class="anchored" data-anchor-id="project-proposal">Project Proposal</h2>
<section id="overview" class="level3">
<h3 class="anchored" data-anchor-id="overview">Overview</h3>
<p>We will create a <strong>real-time 3-band equalizer (EQ)</strong> that can independently remove or boost lows, mids, and highs in an incoming stereo audio signal. The system will feature <strong>three control knobs</strong>, one for each frequency range.</p>
<p>The project will accept audio through a <strong>standard 1/8-inch (3.5 mm) auxiliary input</strong>, allowing playback from a computer or mobile device. The analog audio signal will be digitized by an <strong>ADC</strong>, processed in real time by an <strong>FPGA</strong> using digital filtering, and then converted back to analog via a <strong>DAC</strong> for playback through a pair of speakers (left and right).</p>
<p>The design is going to be developed and implemented on an STM32L432KC Microcontroller, and an iCE40 UltraPlus FPGA.</p>
<hr>
</section>
<section id="functional-specifications" class="level3">
<h3 class="anchored" data-anchor-id="functional-specifications">Functional Specifications</h3>
<ul class="task-list">
<li><p><label><input type="checkbox"><strong>Input / Output</strong>:<br>
Audio is input via a 1/8-inch aux cable and output through a speaker in the digital lab.</label></p></li>
<li><p><label><input type="checkbox"><strong>Bypass Behavior</strong>:<br>
When all EQ knobs are in their default (neutral) positions, the output should closely match the original input audio.</label></p></li>
<li><p><label><input type="checkbox"><strong>Frequency Bands</strong>:<br>
The equalizer will feature three independently adjustable bands:</label></p>
<ul>
<li><strong>Low band:</strong> ~100 Hz – 400 Hz<br>
</li>
<li><strong>Mid band:</strong> ~400 Hz – 2 kHz<br>
</li>
<li><strong>High band:</strong> ~2 kHz – 8 kHz</li>
</ul></li>
<li><p><label><input type="checkbox"><strong>Control Interface:</strong><br>
Each band will have its own <strong>potentiometer</strong> for analog gain adjustment (boost/cut).</label></p></li>
<li><p><label><input type="checkbox"><strong>Latency:</strong><br>
The system will maintain real-time operation with <strong>&lt; 50 ms latency</strong>, ensuring audio remains synchronized with video sources such as YouTube.</label></p></li>
<li><p><label><input type="checkbox"><strong>Filtering Performance:</strong><br>
Each EQ band must correctly boost or attenuate its designated frequency range without introducing distortion or unintended interaction between bands. The correctness of filtering behavior will be verified through both frequency response measurements and subjective listening (ear tests).</label></p></li>
<li><p><label><input type="checkbox"><strong>Verification:</strong><br>
The final report will include theoretical frequency responses for each band and confirm them via hardware measurements.</label></p></li>
</ul>
<hr>
</section>
<section id="system-partitioning" class="level3">
<h3 class="anchored" data-anchor-id="system-partitioning">System Partitioning</h3>
<section id="fpga-responsibilities" class="level4">
<h4 class="anchored" data-anchor-id="fpga-responsibilities"><strong>FPGA Responsibilities</strong></h4>
<ul>
<li>Perform real-time <strong>IIR-based filtering</strong> for the three EQ bands.</li>
<li>Handle <strong>I²S communication</strong> with both ADC and DAC devices.</li>
<li>Generate appropriate <strong>clock signals</strong> using internal oscillators (HSOSC or LFOSC).</li>
</ul>
</section>
<section id="mcu-responsibilities" class="level4">
<h4 class="anchored" data-anchor-id="mcu-responsibilities"><strong>MCU Responsibilities</strong></h4>
<ul>
<li>Read <strong>three analog potentiometer inputs</strong> (one per frequency band).</li>
<li>Compute <strong>IIR filter coefficients</strong> based on knob positions.</li>
<li>Transmit updated coefficients to the FPGA via <strong>SPI</strong>.</li>
</ul>
</section>
</section>
<section id="analog-to-digital-converter-adc-responsibilities" class="level3">
<h3 class="anchored" data-anchor-id="analog-to-digital-converter-adc-responsibilities"><strong>Analog to Digital Converter (ADC) Responsibilities</strong></h3>
<ul>
<li>Convert analog data to digital data</li>
<li>Communicate over I2S protocol</li>
</ul>
</section>
<section id="digital-to-analog-converter-dac-responsibilities" class="level3">
<h3 class="anchored" data-anchor-id="digital-to-analog-converter-dac-responsibilities"><strong>Digital to Analog Converter (DAC) Responsibilities</strong></h3>
<ul>
<li>Convert digital data to analog data</li>
<li>Communicate over I2S protocol</li>
</ul>
</section>
<section id="risks-for-project" class="level3">
<h3 class="anchored" data-anchor-id="risks-for-project"><strong>Risks for project</strong></h3>
<ul>
<li>End-to-end latency (ADC → FPGA processing → DAC) or buffering delays cause audible lag, clicking, or make the system unusable for live monitoring.</li>
<li>Making the ADC, DAC, MCU and FPGA clocks not synchronized</li>
<li>Increased quantization noise from using 16-bit data paths</li>
<li>High-frequency content aliasing into the audio band if the ADC sample rate or analog filter are insufficient.</li>
<li>Incorrect wiring between components</li>
<li>Output clipping at high volume damaging speakers or hearing.</li>
<li>Exceeding FPGA LUT’s, and more importantly, <strong>DSP slices</strong></li>
<li><ul>
<li>Our FPGA Contains only 8 16x16 DSP slices, requiring clever pipelining and multiplexing to filter all signals in time</li>
</ul></li>
</ul>
<hr>
</section>
<section id="hardware-components" class="level3">
<h3 class="anchored" data-anchor-id="hardware-components">Hardware Components</h3>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Component</th>
<th>Quantity</th>
<th>Function</th>
<th>Interface</th>
<th>Approx. Cost</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://www.digikey.com/en/products/detail/adafruit-industries-llc/6250/26249971"><strong>Adafruit PCM5102 I²S DAC</strong></a></td>
<td>1</td>
<td>Digital-to-Analog Converter</td>
<td>I²S</td>
<td>~$6</td>
<td>16–32 bit, 8–384 kHz sampling, 3.3V logic, 2.1 V-rms output</td>
</tr>
<tr class="even">
<td><a href="https://www.amazon.com/PCM1808-Single-Ended-Analog-Input-Decoder-Amplifier/dp/B0D9LNGBD1/ref=sr_1_2?crid=36BETC5DF3MKP&amp;dib=eyJ2IjoiMSJ9.nlR0qPjoFMWLXWvcVm5knddFFm91uZHicUMUQt7fQD2tq6s6qm5W_n4pyBM6xX-trNWgHX6ewn1atXHg6hRTejlrJI4auPOkpfjZueUFzJ0HZSB1_9DcHHzd51PVCwachjMeg7oem3HzbDuk_DUKRi_Ou52n5owbxklLTIAMG7AehH1ymr8ug4BEVaRgoWhk7Gr5YJGwMOrE1Mv-jY4hdG5l_VchhpsW65TVBDcg-eXAThgxDyTGwFhXx4VQ6AGPKSC5HkG-lvhaMzcYhnWzVMCcgTSM6joVPOTBo1RBNyI.Pa8c9lwcgTzKRZBqkcgd8nNLlCZvq8dwTe9jsdVm5MM&amp;dib_tag=se&amp;keywords=PCM1802&amp;qid=1760390332&amp;s=industrial&amp;sprefix=%2Cindustrial%2C356&amp;sr=1-2"><strong>PCM1808 ADC</strong></a></td>
<td>1</td>
<td>Analog-to-Digital Converter</td>
<td>I²S</td>
<td>~$6</td>
<td>24-bit, 8–96 kHz sampling, 3.3–5V supply</td>
</tr>
<tr class="odd">
<td><a href="https://www.digikey.com/en/products/detail/kycon-inc/STX-3000/9975995"><strong>STX-3000 Audio Jack</strong></a></td>
<td>1</td>
<td>Stereo audio input connector</td>
<td>Analog</td>
<td>~$1</td>
<td>3.5 mm TRS jack, through-hole and breadboard compatible</td>
</tr>
<tr class="even">
<td><strong>3362 1/4-inch Square Trimpot Potentiometers</strong></td>
<td>3</td>
<td>User control for low, mid, and high bands</td>
<td>Analog</td>
<td>Stockroom</td>
<td>Reads by MCU ADC pins</td>
</tr>
<tr class="odd">
<td><strong>ICE40 UltraPlus FPGA Board</strong></td>
<td>1</td>
<td>Real-time DSP core</td>
<td>I²C, SPI</td>
<td>On Hand</td>
<td>Performs all filtering</td>
</tr>
<tr class="even">
<td><strong>STM32L432KC MCU Board</strong></td>
<td>1</td>
<td>User interface and coefficient computation</td>
<td>SPI, ADC</td>
<td>On Hand</td>
<td>Communicates with FPGA</td>
</tr>
<tr class="odd">
<td><strong>Miscellaneous Components</strong></td>
<td>n/a</td>
<td>Op-amps, resistors, capacitors, wires</td>
<td>Analog</td>
<td>Stockroom</td>
<td>Used for signal conditioning, biasing, and connections</td>
</tr>
</tbody>
</table>
<p><strong>Subtotal parts cost:</strong> ~<strong>$13</strong> (excluding lab stock components).</p>
<p><strong>Shipping and Taxes:</strong> ~<strong>$8</strong></p>
<p><strong>Total external parts cost:</strong> ~<strong>$21</strong>.</p>
<hr>
</section>
<section id="block-diagram" class="level3">
<h3 class="anchored" data-anchor-id="block-diagram">Block Diagram</h3>
<img src="flow_chart.png" class="img-fluid">
<figcaption>
Figure 1: Flow Chart of Partitioning and Connections.
</figcaption>
</section>
<section id="performance-calculations" class="level3">
<h3 class="anchored" data-anchor-id="performance-calculations">Performance Calculations</h3>
<p>The key performance characteristics of our EQ filter are defined by the sampling rate, ADC/DAC bit rate, and FPGA processing speed.</p>
<p><strong>Sampling Rate / Nyquist:</strong><br>
By the Shannon–Nyquist theorem, the sampling frequency must exceed twice the highest signal frequency. Since the human ear can hear to around ~20 kHz, <span class="math inline">\(f_s &gt; 40\,\text{kHz}\)</span>.<br>
We will use <strong>48 kHz</strong>, providing a 24 kHz Nyquist limit and headroom for filtering.</p>
<p><strong>Bit Rate:</strong><br>
At 48 kHz, 24 bits/sample, and stereo audio:</p>
<p><span class="math display">\[
R = f_s \times B \times C = 48{,}000 \times 24 \times 2 \approx 2.3\,\text{Mbps}
\]</span></p>
<p>With 32-bit I²S frames, the bit clock is approximately <strong>3 MHz</strong>, easily handled by the FPGA.</p>
<p><strong>FPGA Throughput and Latency:</strong><br>
Assuming a 48 kHz sample rate (sample period ≈ 20.83 µs), a 50 MHz fabric clock gives</p>
<p><span class="math display">\[
\frac{50\ \text{MHz}}{48\ \text{kHz}} \approx 1042
\]</span></p>
<p>cycles per sample, which is more than sufficient for three IIR filters using time-multiplexed multiplies. If the ADC and DAC run from the same sample clock and we complete filtering within one sample period, the per-sample processing latency is about 20.8 µs (<span class="math inline">\(\frac{1}{f_{ADC/DAC}}\)</span>). The ADC/DAC and any pipelining typically add only a few samples of delay (on the order of tens of microseconds). Even with conservative buffering, end-to-end latency remains <strong>≪ 50 ms</strong>, easily meeting our real-time requirement.</p>
<p><strong>Resolution / Noise:</strong><br>
24-bit audio provides ~146 dB theoretical SNR; internal 32-bit accumulation will preserve precision and avoid quantization noise.</p>
<p>Overall, the design easily meets real-time performance needs: 48 kHz sample rate, &lt;1 ms latency, and sufficient precision for transparent audio quality.</p>
<p><strong>LUT Usage</strong></p>
<p>Because the filtering is duplicated, we duplicate the filtering hardware. The 3-band EQ consists of 3 cascading filters (low, mid, high), with each band using biquads. That means that we do <span class="math inline">\(3 x 5 = 15\)</span> multiplies per sample. These are 16 bit multiples, and the FPGA has 8 16x16 DSP slices. That means that as long as we run the FPGA at least 1.875 times the sampling frequency of the ADC/DAC then we can fit in all the multiplies. For a sampling rate of 48 KHz, this will be easy as the FGPA can run on order of MHz.</p>
</section>
<section id="project-timeline-and-task-division" class="level3">
<h3 class="anchored" data-anchor-id="project-timeline-and-task-division">Project Timeline and Task Division</h3>
<p>The table below outlines the major project milestones, their target completion dates, and the team member responsible for leading each task. Tasks are ordered chronologically to ensure smooth integration of the hardware and firmware components leading up to a functional prototype.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Task</th>
<th>Goal Date</th>
<th>Lead Member</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Order parts (after project approval)</td>
<td>As soon as approved</td>
<td>Drake</td>
</tr>
<tr class="even">
<td>Successfully throughput unfiltered audio</td>
<td>11/10</td>
<td>Drake</td>
</tr>
<tr class="odd">
<td>Successfully demo filtering in MATLAB</td>
<td>11/10</td>
<td>Eoin</td>
</tr>
<tr class="even">
<td>Successfully measure potentiometer input on MCU</td>
<td>11/17</td>
<td>Drake</td>
</tr>
<tr class="odd">
<td>Finish RTL design and verification via test benches</td>
<td>11/17</td>
<td>Eoin</td>
</tr>
<tr class="even">
<td>Complete and test working prototype</td>
<td>11/24</td>
<td>Whole Team</td>
</tr>
</tbody>
</table>
<p><strong>Task Division:</strong><br>
Drake will primarily focus on the hardware integration side of the project, including part procurement, audio signal interfacing, and MCU testing. Eoin will lead the digital signal processing implementation, including MATLAB filter validation and FPGA RTL design with test benches. Both team members will collaborate closely in the final integration and prototype testing phase to ensure seamless hardware–software coordination and successful real-time operation.</p>
<p>As the project progresses, we will monitor our progress and reallocate tasks as needed to ensure balanced workloads and timely completion. Work will be tracked through a shared action-items spreadsheet. Additionally, we both aim to maintain a complete understanding of the entire system, ensuring that each of us can independently explain and reproduce every part of the project.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/eoinoconnell04\.github\.io\/E155-Portfolio\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>