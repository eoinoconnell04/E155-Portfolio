[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Initial Reflections\n\n\nOverview of my background in digital design and goals in E155.\n\n\n\n\n\nAug 29, 2025\n\n\nEoin O’Connell\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\nWelcome to my Quarto portfolio\n\n\n\n\n\nAug 28, 2025\n\n\nEoin O’Connell\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "Labs",
    "section": "",
    "text": "Lab1: FPGA and MCU Setup and Testing"
  },
  {
    "objectID": "labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "href": "labs.html#lab-1-fpga-and-mcu-setup-and-testing",
    "title": "Labs",
    "section": "",
    "text": "Lab1: FPGA and MCU Setup and Testing"
  },
  {
    "objectID": "labs.html#lab-2-multiplexed-7-segment-display",
    "href": "labs.html#lab-2-multiplexed-7-segment-display",
    "title": "Labs",
    "section": "Lab 2: Multiplexed 7-Segment Display",
    "text": "Lab 2: Multiplexed 7-Segment Display\nLab 2: Multiplexed 7-Segment Display"
  },
  {
    "objectID": "labs.html#lab-3-keypad-scanner",
    "href": "labs.html#lab-3-keypad-scanner",
    "title": "Labs",
    "section": "Lab 3: Keypad Scanner",
    "text": "Lab 3: Keypad Scanner\nLab 3: Keypad Scanner"
  },
  {
    "objectID": "labs.html#lab-4-digital-audio",
    "href": "labs.html#lab-4-digital-audio",
    "title": "Labs",
    "section": "Lab 4: Digital Audio",
    "text": "Lab 4: Digital Audio\nLab 4: Digital Audio"
  },
  {
    "objectID": "labs.html#lab-5-interrupts",
    "href": "labs.html#lab-5-interrupts",
    "title": "Labs",
    "section": "Lab 5: Interrupts",
    "text": "Lab 5: Interrupts\nLab 5: Interrupts"
  },
  {
    "objectID": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6-the-internet-of-things-and-serial-peripheral-interface",
    "title": "Labs",
    "section": "Lab 6: The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6: The Internet of Things and Serial Peripheral Interface\nLab 6: The Internet of Things and Serial Peripheral Interface"
  },
  {
    "objectID": "labs.html#lab-7-the-advanced-encryption-standard",
    "href": "labs.html#lab-7-the-advanced-encryption-standard",
    "title": "Labs",
    "section": "Lab 7: The Advanced Encryption Standard",
    "text": "Lab 7: The Advanced Encryption Standard\nLab 7: The Advanced Encryption Standard"
  },
  {
    "objectID": "posts/initial_reflection.html",
    "href": "posts/initial_reflection.html",
    "title": "Initial Reflections",
    "section": "",
    "text": "This is my third digital design class at Harvey Mudd, starting with E85: Digital Electronics and Computer Engineering, followed by E154: System-on-Chip Design, and now E155: Microprocessor Systems Design and Application.\nLast summer I worked as a Physical Design intern at Tenstorrent, working on a RISC-V processor, so I am excited to get exposure to a completely different part of computer engineering, for very different applications.\nI expect this class to be quite challenging, particularly with time managament. My goals are to stay multiple days ahead of due dates—not my normal inclination—to avoid long nights and extra stress if possible.\nI am quite excited for a lot of the labs, particularly the 7 segment display lab, as well as the ditial audio lab. I think the 7 segment display is a very clear application that has a lot of uses, and I think it would be cool to connect multiple displays together to be able to print out longer messages. Additionally, as a musician, I am excited to work on the digital audio lab, and would be excited to expand this to include a keyboard.\nOverall, I am very excited to see where this class takes me."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "This lab aimed to gain familiarity with the FPGA and MCU, and creating a simple seven segment display, as well as controlling some other LED functions."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "",
    "text": "This lab aimed to gain familiarity with the FPGA and MCU, and creating a simple seven segment display, as well as controlling some other LED functions."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThis lab consisted of two main challenges, creating a blinking light at 2.4 Hz, and a seven segment display illuminating hexadecimal digits as specified by 4 dip switches.\n\nBlinking LED\nThe on-board high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitive library was used to generate a clock signal at 48 MHz. Then, a counter was used to divide the high frequency clock signal down to 2.4 Hz specifically. The most simple clock dividers have a counter that overflows, and this makes it simple to divide the frequency by powers of two. Because 2.4 Hz, does not satisfy that for 48 Mhz, we need to establish the specific number of cycles that it takes take the perfect amount of time.\nMy design divided the clock frequency to 4.8 Hz, so that the LED would have a 50% duty cycle and a 2.4 Hz overall frequency. I used the equation: n * 1/48,000,000 = 1/4.8. Then, n = 48,000,000/4.8 = 10,000,000. Because the count starts at zero, I will keep increasing the count each cycle until it reaches 9,999,999, and then I will reset it for the next cycle and switch the LED from on to off, or from off to on.\nTo test this, I connected the LED prong to an oscilloscope, and measured the frequency. The measured frequency was 2.402 Hz, confirming the design’s function.\n\n\nSeven Segment display\nThe goal was to use the 4 input DIP switches to control the seven segment display, and ensure that all digits were unique (ex: 6 and b must be distinguishable). The first step was to map each hexadeciaml digit to the seven segment display and determine which panels should be on. Then, this was implemented using a case statement in SystemVerilog which turned the truth table into hardware.\n\n\nTestbenches\nBoth the top level module and the seven segment display module have automatic testbenches to check all possible permutations of input s[3:0], the 4 DIP switches. This simulates the output to make sure that the verilog has the expected functionality in all cases.\nAdditionally, I created a testbench for a modified version of the divider module (divider_test_version), which instead of dividing a clk frequency by 20,000,000, it divides it by 20. This will check that the module works as expected, while still being managable (doesn’t require simulating millions of clock cycles to check if a single bit changed).\n\n\nVisual test\nThe seven segment display and LEDs are also most easily tested through the simple eye test. By going through all 16 combinations of the DIP switches, I can confirm that all hexadecimal digits are shown and distinct, and that the two LEDs that are a function of the swtiches work as correctly, and that the third LED blinks at around 2.4 Hz. Of course, this is a supplement to more rigorous tests, but this is quite effective at detecting bugs that could be common in both the SystemVerilog and the testvectors, because a lot of the cases were copied from one to the other."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe code for my project can be found on my github page. Lab1 Github Repository\n\nBlock Diagram\n\n\nFigure 1: Block Diagram of the Verilog design.\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module top includes three submodules: the high-speed oscillator block (HSOSC), the clock divider module (divider), and the seven segment display decoder (display).\n\n\nSchematic\n\n\nFigure 2: Schematic of the Physical Circuit.\n\nFigure 2 shows the physical layout of the design. Note that led[3:0] have pins that were on the ribbon connector ports so that they could be passed to external LEDs on the breadboard due to a supply shortage of SMT diodes. Each led has a 1k \\(\\Omega\\) current-limiting resistor to ensure the output current, ~2.6 mA, does not exceed the maximum current rating for the FPGA GPIO pins.\nTo calculate the pull down resistors for the seven segement display, I used the datasheet of the display itself. This I chose to use 1k \\(\\Omega\\) as it was over the minimum safe resitance value and still provided a very bright display. Using a larger resistor in this case will only make the circuit safer, it just could reduce the brightness (even to the point of the LED not illuminating).\nI was powering the LED with 3.3 V, and the seven segment display has a typical forward voltage of 1.95 V. That means that we need to dissipate up to 1.35 V through the resistor. My starting point for choosing the resistance was to use 1k \\(\\Omega\\) resistors, just like the on board LEDs. Using V = I*R, I get \\(I = V/R = 1.35 / 1000 = 1.35\\) mA. This is an acceptable current for the FPGA GPIO pins, so this is the resistor value that I choose."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI accomplished all of the perscribed tasks: the standalone LEDs function as expected and the seven segement display shows all 16 hexadecimal digits, all controlled by the 4 DIP switches. For the 2.4 Hz pulsing LED, my oscilloscope measured 2.402 Hz frequency, but there was quite a bit of noise on the rising and falling edge of the signal. I am not sure if this small error is a measure effect, or perhaps it is comming from the oscillator itself. Regarless, this shows that the clock divider circuit is working as intended, with very minimal error.\n\nTestbench Simulation\nThe first testbench is to simulate the top level module. We can see the waveforms match the expected values. Note that for the simulation led[2] is floating because the oscillator is commented out because it cannot be simulated. Therefore, the expected output is led[1:0] appended in front of seg, giving us a 9 digit expected output.\n\n\nFigure 3: Top level module wave forms.\n\nNot only do we see the wave forms match, but we get a printout that all 16 possible permutations tests passed.\n\n\nFigure 4: Top level module testbench output.\n\nSimilarly for simulating the seven segment display module, we give the input switches s, and see the output seg matches the expected values.\n\n\nFigure 5: Seven segment display module waveforms.\n\nAgain, all 16 possible combinations of s matched the expectation.\n\n\nFigure 6: Seven segment display testbench output.\n\n\n\nFigure 7: Test version of clock divider module waveforms.\n\nHere we can see that the test verison spends 10 cycles at zero and 10 cycles at one. This divides the frequency by 20. This testbench is much easier to keep track of then trying to simulate the clock divider that counts to 10,000,000, as you would need to simulate so many more cycles just to see a change in the divided_clk signal.\nHere we can see that by counting to 10 for both the LED being on and off yeilds a total reduction in frequency by a factor of 20. Thus, by counting to 10,000,000, we get a frequency reduction by a factor of 20,000,000. That brings our 4.8 MHz clock to 2.4 Hz.\n\n\nFigure 8: Test version of clock divider module testbench output.\n\nJust like how the waveforms for the divided_clk and expected signals match, we get confirmation that all tests passed by the testbench output."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "Conclusion",
    "text": "Conclusion\nI worked on this lab for three consecutive days, totalling around 15 hours. This included around 3 hours to solder the board and get setup, a few hours working on the demos, before working on the project itself. Writting the verilog only took about 45 minutes, as the idioms are quite simple once you understand the clock divider logic. I spent around 3 hours writing up the report and making diagrams.\nThe FPGA succesfully controlled both the seven segment display as well as the 3 standalone LEDs. The first two LEDs perform the XOR and AND functions correctly, and the third LED blinks at 2.4 Hz as desired.\nThe main assignment issue was simply a shortage of parts, which made certain functions more difficult to implement and test. For me, this meant that I had no on-board LEDs so I will have to solder and test these at a later date. For the assignment itself, I found it straightforward."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab 1: FPGA and MCU Setup and Testing",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\nPrompt: Write SystemVerilog HDL to leverage the internal high speed oscillator in the Lattice UP5K FPGA and blink an LED at 2 Hz. Take full advantage of SystemVerilog syntax, for example, using logic instead of wire and reg.\n\nThe code generated by ChatGPT base free model, which I believe to be GPT-5 but the website does not specify for my free acount. The file can be viewed here on my github.\nThe first thing I was impressed by was that the AI seemed to get the clock oscillator correct. Here you can see the difference between my code and the AI output from the simple prompt.\nAI Clock Generation:\nHSOSC #(\n        .CLKHF_DIV(\"0b00\")   // 48 MHz (00), 24 MHz (01), 12 MHz (10), 6 MHz (11)\n    ) hf_osc_inst (\n        .CLKHF(clk_hf),\n        .CLKHFEN(1'b1),      // enable output\n        .CLKHFPU(1'b1)       // power up oscillator\n    );\nMy Clock generation (from lab1 source code):\nHSOSC hf_osc (.CLKHFPU(1'b1), .CLKHFEN(1'b1), .CLKHF(clk));\nFurthermore, the clock divider function was very simple and similar to what I would have wrote:\n// Counter divider\n    logic [24:0] counter;   // enough bits for ~0.5s interval at 48 MHz\n    logic led_reg;\n\n    always_ff @(posedge clk_hf) begin\n        counter &lt;= counter + 1;\n\n        // Toggle LED at ~2 Hz (0.5s high, 0.5s low)\n        if (counter == 24_000_000) begin\n            led_reg &lt;= ~led_reg;\n            counter &lt;= 0;\n        end\n    end\nFor the clock to get down to 2 Hz, my math is that n * 1/48,000,000 = 4 (2 times the clock frequency so that the duty cycle is 50% and the overall frequncy is 2 Hz). This means that it should count 12,000,000 cycles before flipping. The way the AI did it was that the overall frequency is 1 Hz because it spends 0.5s high and 0.5s low, which is 1 Hz as each cycle takes 1 s.\nBesides that minor misunderstanding, I was quite impressed by the AI output.\nWhen I synthesized the AI ouput in Radiant, it compiled and synthesized with no errors on the very first try. I think that with slightly more guidance on the clock divider instructions, then this would work as expected.\nI was using Cursor extensively over the summer at my internship at Tenstorrent, and I found it extremely powerful because it has context of your other files and you don’t need to copy and paste back and forth from a website. I will try to get a student license, but the first half of this course is no AI allowed, so I will only be able to use it on the project."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "This lab aimed to gain familiarity with clock multiplexing and PNP transistors, through driving 2 seven segment displays with a single set of GPIO pins that rapidly switches back and forth at the same frequency as the power driving both displays. This gives the illusion that both are on simultaenously because our eyes cannot detect how fast the displays are switching on and off."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "",
    "text": "This lab aimed to gain familiarity with clock multiplexing and PNP transistors, through driving 2 seven segment displays with a single set of GPIO pins that rapidly switches back and forth at the same frequency as the power driving both displays. This gives the illusion that both are on simultaenously because our eyes cannot detect how fast the displays are switching on and off."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThis challenge of this lab was using a single seven segment display module, and a corresponding single set of 7 GPIO pins to control two different seven segment display panels with different numbers. The trick is to rapidly switch the signals on outputed by the pins, and at the same frequency change which display gets power. That gives the illusion that both segements are continuously illuminated, but in reality it is only ever one at a time. This requires some testing to make sure that all the parts work together as intended.\n\nSeven Segment display\nThe display module takes a 4 bit signal and decodes it to control the seven segment display, ensuring that all digits were unique (ex: 6 and b must be distinguishable). The first step was to map each hexadeciaml digit to the seven segment display and determine which panels should be on. Then, this was implemented using a case statement in SystemVerilog which turned the truth table into hardware. This module was already tested in lab 1, and comfirmed with a testbench, so we can be sure that this module works as expected.\n\n\nClock divider\nLikewise, the clock divider was used in lab 1 as well. The parameter that changes the TOGGLE_COUNT was modified to output a faster frequency than lab 1 so that the human eye cannot detect flickering, but it is otherwise unchagned. Again this has it’s own testbench to ensure proper functionality, but we can also use this knowing that it works correctly.\n\n\nTop Level module\nSimulating the top level module was probably the most challenging aspect of all of lab 2. I changed the TOGGLE_COUNT parameter to flip every cycle (halving the clock frequency), so that the wave forms were more managable. Next, the challenge was getting testvector coverage for all \\(2^8\\) combinations of input switches, and also ensuring that the control signals that turn each one on or off were lined up correctly. To do this, I wrote a python script that generated these test vectors so they didn’t have to be hand written. This made it very easy to modify the testvectors as I identified bugs and changed the functionality of the module (it took me a few iterations to get the top level module outputs correct).\nThis module also tests the mux and adder logic, and this is built into the testvectors.\n\n\nEye test\nFor this type of project, the simple eye test is very important. Just because the verilog works as expected, we need to make sure that the chosen frequency for switching digits is fast enough to not notice flickering, but slow enough to not see any digits bleeding into each other."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe code for my project can be found on my github page. Lab2 Github Repository\n\nBlock Diagram\n\n\nFigure 1: Block Diagram of the Verilog design.\n\nThe block diagram in Figure 1 demonstrates the overall architecture of the design. The top-level module top includes three submodules: the high-speed oscillator block (HSOSC), the clock divider module (divider), and the seven segment display decoder (display).\nIt also includes a mux to switch between the two DIP switch input signals, an adder to sum together the input signals, and an inverter to create a set of opposing display control signals (when one is one the other is off and vice versa).\n\n\nSchematic\n\n\nFigure 2: Schematic of the Physical Circuit.\n\nFigure 2 shows the physical layout of the design. We have 5 leds on the breadboard controlled by led[4:0], and these have current limiting resistors. The green LEDs that I am using have a voltage drop around 2.2 volts, so the current through the resistor is \\(V/R = (3.3 - 2) / 330 = 3.9\\) mA. This is an acceptable current for the FGPA pins. I used 1k \\(\\Omega\\) resistors in lab1 and the LEDs were quite dim so I wanted to to have a brighter LED that was still safe for the FGPA in lab 2.\nAdditionally, I need resistors for the 7 segment display. In lab 1 I had current limiting resistors, but they were wired incorrectly and were not functioning as intended. Here I fixed that issue, but the calculation is the same from lab 1. The seven segment display has a typical forward voltage of 1.95 V (from datasheet), the PNP transistor has a Collector−Emitter Saturation Voltage of around 0.2 V, and given the 3.3 V input, we have an base voltage of \\(3.3 - 1.95 - 0.2 = 1.15\\). we get \\(I = V/R = 1.15 / 330 = 3.48\\) mA. This is an acceptable current for the FPGA GPIO pins, and the seven segment display has a bright clear ouptut, so this is what was used.\nFinally, I need to calculate the resistor for the gate of the PNP transistor. From the data sheet, the Base−Emitter Saturation Voltage has a typical value of \\(0.9\\) V. That means the base is sitting at \\(3.3-0.9 = 2.4\\) V. My initial choice was a 2.2 k \\(\\Omega\\) resistor, which gives \\(2.4/2200 = 1.09\\) mA through the FPGA pin. This is a perfectly acceptable FPGA current, and the transistor is operating correctly so it is used for this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Results and Discussion",
    "text": "Results and Discussion\nI accomplished all of the perscribed tasks: the 5 standalone LEDs display the sum of the two hexadecimal digits as expected, and the two digit seven segement display shows both digits with no flickering, with all digits at an even brightness. This is controlled by the 4 dip switches on the board, as well as a secondary set of dip switches on the breadboard.\n\nTestbench Simulation\nThe first testbench is to simulate the top level module. We can see the waveforms match the expected values. For this test, I modified the parameter TOGGLE_COUNT for the divider to make the divided clock only half the frequency of the regular clock. This allows for a much more managable testbench as we do not need to wait thousands of cycles for the divided_clk to flip.\nTo generate the long test vectors file for the top level module to have complete coverage of all input combinations, I wrote a short python script generate_lab2_eo_testvectors.py which loops through all input combinations and appends one cycle with the first digit illuminated, and a second cycle with the second digit, before moving to the next switch combination. This made it very easy to modify the test vectors as I developed the module itself, instead of working on a very large complex testvector file directly.\n\n\nFigure 3: Top level module wave forms.\n\nIn figure 3, we see that the expected and simulated waveforms match. Of course, this is only the first couple cycles, but this continuous for all 512 tests. The 512 tests covers all \\(2^8\\) combinations of switches twice, as it includes 2 cycles per combination to allow the mux to select both inputs and flash the number on the respective panel.\n\n\nFigure 4: Top level module testbench output.\n\nFigure 4 output also confirms that the 512 tests matched the expectation, including the LEDs, the seven segment display, and the display selection signals.\n\n\nFigure 5: Seven segment display module waveforms.\n\nHere, we are using the exact same unmodified display module from lab1, and we have the same test bench to confirm it’s functionality. We test for all combinations of s, and ensure that the 7 bit binary output is as expected.\n\n\nFigure 6: Seven segment display testbench output.\n\nFigure 6 shows that all 16 possible combinations of s matched the expectation.\n\n\nFigure 7: Test version of clock divider module waveforms.\n\nJust like the seven segment display decoder, we are reusing the clock divider as well.\nHere we can see that the test verison spends 10 cycles at zero and 10 cycles at one. This divides the frequency by 20. This testbench is much easier to keep track of then trying to simulate the clock divider counting thousands of cycles, yet still provides confirmation that it is working as intended.\n\n\nFigure 8: Test version of clock divider module testbench output.\n\nFigure 8 gives confirmation that the module outputs match the expected values for all tests."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "Conclusion",
    "text": "Conclusion\nI found lab 2 significantly easier than lab 1, because I had a gained familiarity with the software and board, and had already assembled my parts. The verilog itself was also very quick, as I was able to reuse my display and divider modules from lab 1. Therefore, I had the verilog and testbenches written in around 2 hours.\nIt took around 2 more hours to assemble my breadboard, and 2 hours debugging some subtle issues. One such issue was that my verilog assumed a active high reset, wheras the board button is active low. That caused the digit to be stuck on one of them and not oscillate back and forth.\nOverall, I worked on this lab for around 12 hours including the writeup and diagrams.\nThe FPGA succesfully controlled both digits on the seven segment display with no noticable flickering, and the 5 led lights that display the sum. The lab was very succesful and I enjoyed working on it.\nI still had issues getting the FPGA programmer to help, but Javier gave me a useful tip which seems to be helping. I might still try out the alternative programmer that has been suggested."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab 2: Multiplexed 7-Segment Display",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\nPrompt 1: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits.\n\nI used my ChatGPT free account to create this, and the file is here on my github.\nI opened up the verilog in Radiant, it synthesized without any issues. The first thing I noticed when looking at the Netlist analyzer is that there are 2 sets of seven segment display outputs. I think that the wording of the prompt suggests this, and that if I wanted to run this on my board (which doesn’t have enough GPIO pins to allow 14 pins for the seven segment display) I could easily ask Chat to fix this for me. Essentially, I think that it was correct for what it was trying to do.\nLooking at the SystemVerilog itself, I noticed that while the AI included pleanty inline comments explaining what each line does, the over style was very poor, with no modules. I think that by modifying the prompt to tell it to use a modular design it would do well on this.\nNext I tried the second prompt given in the lab manual.\n\nPrompt 2: Write SystemVerilog HDL to time multiplex a single seven segment decoder (that decodes from four bits to a common anode seven segment display) to decode two sets of input bits and drive two sets of seven output bits. Use the seven segment decoder and oscillator provided in the attached files.\n\nFor some reason, despite providing the files as context, the LLM did not use the correct port names when instantiating the modules. For example for the divider it used clk_in and clk_out instead of clk and divided_clk which my module uses. Likewise it used in and out for the seven segment display instead of s and seg. It also got the parameter name TOGGLE_COUNT wrong and called it n. Somehow it new what the inputs, outputs, and parameters were, but somehow did not copy over the names correctly.\nI performed those manual changes, the design synthesized correctly. It got the oscillator correct, and the rest of the SystemVerilog code seems reasonable (but also not modular like Prompt 1 response).\nI think that a lot of these errors would be better with a different model and IDE such as Cursor instead of providing the files to chat gpt. During my internship I found that Cursor + Claude Sonnet worked very well and didn’t make these kinds of mistakes, but I do not have access to these anymore. For things like writting modular code, style, and comments, something like a Cursor rules file, or a thing that you add to every prompt/conversation with specific instructions would help get results that are closer to what the user desires."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "I am Eoin O’Connell, a junior engineering student at Harvey Mudd College. I participate on the CMS Cross Country and Track and Field teams. This is my portfolio for E155, Microprocessor Systems: Design & Application."
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Course Webpage"
  }
]